#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
æ™ºèƒ½é—®å·å¡«å†™ç³»ç»Ÿ - ç»Ÿä¸€ä¸»å…¥å£
åŠŸèƒ½ï¼šæ•¢æ­»é˜Ÿä½œç­” â†’ æ”¶é›†ç»“æœ â†’ åˆ†æç»éªŒ â†’ æŒ‡å¯¼å¤§éƒ¨é˜Ÿ â†’ å¤§éƒ¨é˜Ÿä½œç­”
"""

import asyncio
import json
import time
import uuid
import logging
import threading
import subprocess
import platform
from datetime import datetime
from typing import Dict, List, Optional, Any
from flask import Flask, render_template, request, jsonify
from flask_cors import CORS
import pymysql.cursors
import requests

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# ğŸ”¥ æ–°å¢ï¼šå¢å¼ºäººç±»åŒ–æ“ä½œé…ç½®
ENHANCED_HUMAN_LIKE_CONFIG = {
    "anti_detection_enabled": True,
    "random_delays": {
        "thinking_time": (0.2, 1.2),      # æ€è€ƒæ—¶é—´èŒƒå›´
        "typing_speed": (0.05, 0.20),     # æ‰“å­—é€Ÿåº¦èŒƒå›´
        "click_delay": (0.1, 0.8),        # ç‚¹å‡»å»¶è¿ŸèŒƒå›´
        "inter_action_pause": (0.3, 2.0)  # æ“ä½œé—´éš”èŒƒå›´
    },
    "input_strategies": [
        "natural_click_and_type",         # è‡ªç„¶ç‚¹å‡»è¾“å…¥
        "hesitation_and_retry",           # çŠ¹è±«é‡è¯•
        "progressive_verification"        # æ¸è¿›éªŒè¯
    ],
    "error_recovery": {
        "max_retries": 3,
        "confusion_recovery_time": (0.8, 2.0),
        "backup_strategies_enabled": True
    },
    "mouse_behavior": {
        "subtle_movements": True,
        "trajectory_randomization": True,
        "micro_adjustments": True
    }
}

# ğŸ”¥ æ–°å¢ï¼šå¢å¼ºäººç±»åŒ–æ“ä½œé…ç½®
ENHANCED_HUMAN_LIKE_CONFIG = {
    "anti_detection_enabled": True,
    "random_delays": {
        "thinking_time": (0.2, 1.2),      # æ€è€ƒæ—¶é—´èŒƒå›´
        "typing_speed": (0.05, 0.20),     # æ‰“å­—é€Ÿåº¦èŒƒå›´
        "click_delay": (0.1, 0.8),        # ç‚¹å‡»å»¶è¿ŸèŒƒå›´
        "inter_action_pause": (0.3, 2.0)  # æ“ä½œé—´éš”èŒƒå›´
    },
    "input_strategies": [
        "natural_click_and_type",         # è‡ªç„¶ç‚¹å‡»è¾“å…¥
        "hesitation_and_retry",           # çŠ¹è±«é‡è¯•
        "progressive_verification"        # æ¸è¿›éªŒè¯
    ],
    "error_recovery": {
        "max_retries": 3,
        "confusion_recovery_time": (0.8, 2.0),
        "backup_strategies_enabled": True
    },
    "mouse_behavior": {
        "subtle_movements": True,
        "trajectory_randomization": True,
        "micro_adjustments": True
    }
}

# ğŸ”¥ æ–°å¢ï¼šå¢å¼ºäººç±»åŒ–æ“ä½œé…ç½®
ENHANCED_HUMAN_LIKE_CONFIG = {
    "anti_detection_enabled": True,
    "random_delays": {
        "thinking_time": (0.2, 1.2),      # æ€è€ƒæ—¶é—´èŒƒå›´
        "typing_speed": (0.05, 0.20),     # æ‰“å­—é€Ÿåº¦èŒƒå›´
        "click_delay": (0.1, 0.8),        # ç‚¹å‡»å»¶è¿ŸèŒƒå›´
        "inter_action_pause": (0.3, 2.0)  # æ“ä½œé—´éš”èŒƒå›´
    },
    "input_strategies": [
        "natural_click_and_type",         # è‡ªç„¶ç‚¹å‡»è¾“å…¥
        "hesitation_and_retry",           # çŠ¹è±«é‡è¯•
        "progressive_verification"        # æ¸è¿›éªŒè¯
    ],
    "error_recovery": {
        "max_retries": 3,
        "confusion_recovery_time": (0.8, 2.0),
        "backup_strategies_enabled": True
    },
    "mouse_behavior": {
        "subtle_movements": True,
        "trajectory_randomization": True,
        "micro_adjustments": True
    }
}

# å¯¼å…¥æ ¸å¿ƒç³»ç»Ÿæ¨¡å—
from questionnaire_system import (
    QuestionnaireManager, 
    DatabaseManager, 
    DB_CONFIG,
    TaskStatus,
    PersonaRole
)

# ä½¿ç”¨å¢å¼ºçš„AdsPower + WebUIé›†æˆæ¨¡å—
try:
    from adspower_browser_use_integration import (
        AdsPowerWebUIIntegration,
        run_complete_questionnaire_workflow,
        run_complete_questionnaire_workflow_with_existing_browser,
        run_intelligent_questionnaire_workflow_with_existing_browser,  # ğŸ”¥ æ–°å¢ï¼šæ™ºèƒ½é—®å·ç³»ç»Ÿå…¥å£
        HumanLikeInputAgent  # ğŸ”¥ æ–°å¢ï¼šå¯¼å…¥å¢å¼ºäººç±»åŒ–è¾“å…¥ä»£ç†
    )
    webui_integration_available = True
    logger.info("âœ… AdsPower + WebUI é›†æˆæ¨¡å—å·²åŠ è½½ï¼ˆåŒ…å«å¢å¼ºäººç±»åŒ–æ“ä½œï¼‰")
except ImportError as e:
    logger.warning(f"âš ï¸ AdsPower + WebUI é›†æˆæ¨¡å—ä¸å¯ç”¨: {e}")
    webui_integration_available = False
    # æä¾›å¤‡ç”¨å‡½æ•°
    async def run_complete_questionnaire_workflow(*args, **kwargs):
        return {"success": False, "error": "AdsPower + WebUI é›†æˆæ¨¡å—ä¸å¯ç”¨"}
    async def run_complete_questionnaire_workflow_with_existing_browser(*args, **kwargs):
        return {"success": False, "error": "AdsPower + WebUI é›†æˆæ¨¡å—ä¸å¯ç”¨"}

# å¯¼å…¥å¢å¼ºç‰ˆAdsPowerç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨
from enhanced_adspower_lifecycle import AdsPowerLifecycleManager, BrowserStatus

# Flaskåº”ç”¨
app = Flask(__name__)
CORS(app)

class BrowserWindowManager:
    """æµè§ˆå™¨çª—å£å¸ƒå±€ç®¡ç†å™¨ - ä¼˜åŒ–çš„6çª—å£æµå¼å¸ƒå±€"""
    
    def __init__(self):
        self.window_positions = []
        self.screen_width = 1920  # é»˜è®¤å±å¹•å®½åº¦
        self.screen_height = 1080  # é»˜è®¤å±å¹•é«˜åº¦
        # ä¼˜åŒ–çš„çª—å£å°ºå¯¸ï¼Œé€‚åˆ6çª—å£å¸ƒå±€
        self.window_width = 640   # æ¯ä¸ªçª—å£å®½åº¦
        self.window_height = 490  # æ¯ä¸ªçª—å£é«˜åº¦ï¼ˆé™ä½ä»¥é€‚åº”6çª—å£ï¼‰
        self.margin = 10         # çª—å£é—´è·
        self._detect_screen_size()
    
    def _detect_screen_size(self):
        """æ£€æµ‹å±å¹•å°ºå¯¸"""
        try:
            if platform.system() == "Darwin":  # macOS
                result = subprocess.run(['system_profiler', 'SPDisplaysDataType'], 
                                      capture_output=True, text=True)
                # ç®€åŒ–å¤„ç†ï¼Œä½¿ç”¨é»˜è®¤å€¼
                pass
            elif platform.system() == "Windows":
                import tkinter as tk
                root = tk.Tk()
                self.screen_width = root.winfo_screenwidth()
                self.screen_height = root.winfo_screenheight()
                root.destroy()
            
            logger.info(f"ğŸ–¥ï¸ æ£€æµ‹åˆ°å±å¹•å°ºå¯¸: {self.screen_width}x{self.screen_height}")
            
        except Exception as e:
            logger.warning(f"âš ï¸ æ— æ³•æ£€æµ‹å±å¹•å°ºå¯¸ï¼Œä½¿ç”¨é»˜è®¤å€¼: {e}")
    
    def calculate_window_positions(self, window_count: int) -> List[Dict]:
        """è®¡ç®—å¤šä¸ªæµè§ˆå™¨çª—å£çš„æœ€ä½³æ’å¸ƒä½ç½® - ä¸“ä¸º6çª—å£ä¼˜åŒ–"""
        positions = []
        
        if window_count <= 0:
            return positions
        
        # ä¼˜åŒ–çš„6çª—å£å¸ƒå±€ç­–ç•¥
        if window_count <= 2:
            # æ•¢æ­»é˜Ÿï¼šå‰2ä¸ªä½ç½®ï¼ˆç¬¬ä¸€è¡Œå·¦è¾¹ä¸¤ä¸ªï¼‰
            cols, rows = 3, 2  # ä¿æŒ3x2ç½‘æ ¼ï¼Œä½†åªä½¿ç”¨å‰2ä¸ªä½ç½®
            target_count = min(window_count, 2)
        elif window_count <= 6:
            # æ ‡å‡†6çª—å£å¸ƒå±€ï¼š3åˆ—2è¡Œ
            cols, rows = 3, 2
            target_count = min(window_count, 6)
        else:
            # è¶…è¿‡6ä¸ªçª—å£æ—¶ï¼Œä½¿ç”¨æ›´å¤§çš„ç½‘æ ¼
            cols, rows = 4, 3
            target_count = min(window_count, 12)
        
        # å›ºå®šçª—å£å°ºå¯¸ä¸ºä¼˜åŒ–å€¼
        window_width = self.window_width
        window_height = self.window_height
        
        # è®¡ç®—æ€»å¸ƒå±€å°ºå¯¸
        total_width = cols * window_width + (cols - 1) * self.margin
        total_height = rows * window_height + (rows - 1) * self.margin
        
        # æ£€æŸ¥æ˜¯å¦è¶…å‡ºå±å¹•
        if total_width > self.screen_width - 50:  # ç•™å‡º50pxè¾¹è·
            # ç¼©å°çª—å£å°ºå¯¸
            scale_factor = (self.screen_width - 50) / total_width
            window_width = int(window_width * scale_factor)
            window_height = int(window_height * scale_factor)
            total_width = cols * window_width + (cols - 1) * self.margin
            total_height = rows * window_height + (rows - 1) * self.margin
        
        # è®¡ç®—èµ·å§‹ä½ç½®ï¼ˆå±å¹•å±…ä¸­ï¼‰
        start_x = (self.screen_width - total_width) // 2
        start_y = (self.screen_height - total_height) // 2
        
        # ç”Ÿæˆæ¯ä¸ªçª—å£çš„ä½ç½®
        for i in range(target_count):
            row = i // cols
            col = i % cols
            
            x = start_x + col * (window_width + self.margin)
            y = start_y + row * (window_height + self.margin)
            
            # ç¡®å®šçª—å£è§’è‰²
            if i < 2:
                role = "scout"  # æ•¢æ­»é˜Ÿå æ®å‰2ä¸ªä½ç½®
            else:
                role = "target"  # å¤§éƒ¨é˜Ÿå æ®å4ä¸ªä½ç½®
            
            positions.append({
                "x": x,
                "y": y,
                "width": window_width,
                "height": window_height,
                "window_index": i,
                "role": role,
                "grid_position": {"row": row, "col": col},
                "margin": self.margin
            })
        
        logger.info(f"ğŸ“ ç”Ÿæˆ6çª—å£æµå¼å¸ƒå±€: {len(positions)} ä¸ªä½ç½® ({cols}x{rows} ç½‘æ ¼)")
        logger.info(f"   çª—å£å°ºå¯¸: {window_width}x{window_height}")
        logger.info(f"   æ•¢æ­»é˜Ÿä½ç½®: {len([p for p in positions if p['role'] == 'scout'])} ä¸ª")
        logger.info(f"   å¤§éƒ¨é˜Ÿä½ç½®: {len([p for p in positions if p['role'] == 'target'])} ä¸ª")
        
        return positions
    
    def get_scout_positions(self, window_count: int) -> List[Dict]:
        """è·å–æ•¢æ­»é˜Ÿä¸“ç”¨çª—å£ä½ç½®ï¼ˆå‰2ä¸ªï¼‰"""
        all_positions = self.calculate_window_positions(max(window_count, 6))
        scout_positions = [p for p in all_positions if p['role'] == 'scout']
        return scout_positions[:window_count]
    
    def get_target_positions(self, window_count: int) -> List[Dict]:
        """è·å–å¤§éƒ¨é˜Ÿä¸“ç”¨çª—å£ä½ç½®ï¼ˆå4ä¸ªï¼‰"""
        all_positions = self.calculate_window_positions(6)  # æ€»æ˜¯åŸºäº6çª—å£å¸ƒå±€
        target_positions = [p for p in all_positions if p['role'] == 'target']
        return target_positions[:window_count]
    
    def apply_window_position(self, browser_profile_id: str, position: Dict):
        """åº”ç”¨çª—å£ä½ç½®åˆ°AdsPoweræµè§ˆå™¨"""
        try:
            # è¿™é‡Œå¯ä»¥é€šè¿‡AdsPower APIè®¾ç½®çª—å£ä½ç½®
            # æš‚æ—¶è®°å½•ä½ç½®ä¿¡æ¯
            role_text = "æ•¢æ­»é˜Ÿ" if position.get('role') == 'scout' else "å¤§éƒ¨é˜Ÿ"
            logger.info(f"ğŸªŸ è®¾ç½®{role_text}æµè§ˆå™¨ {browser_profile_id} ä½ç½®: "
                       f"({position['x']}, {position['y']}) "
                       f"{position['width']}x{position['height']}")
            return True
        except Exception as e:
            logger.warning(f"âš ï¸ è®¾ç½®çª—å£ä½ç½®å¤±è´¥: {e}")
            return False

class KnowledgeBase:
    """å†…ç½®çŸ¥è¯†åº“ç®¡ç†å™¨"""
    
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
    
    def save_scout_experience(self, session_id: str, questionnaire_url: str, 
                            persona_id: int, persona_name: str, 
                            question_content: str, answer_choice: str, 
                            success: bool, reasoning: str = "") -> bool:
        """ä¿å­˜æ•¢æ­»é˜Ÿç­”é¢˜ç»éªŒ"""
        try:
            connection = self.db_manager.get_connection()
            with connection.cursor() as cursor:
                sql = """
                INSERT INTO questionnaire_knowledge 
                (session_id, questionnaire_url, persona_id, persona_name, 
                 question_content, answer_choice, success, reasoning, created_at)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
                """
                cursor.execute(sql, (
                    session_id, questionnaire_url, persona_id, persona_name,
                    question_content, answer_choice, success, reasoning, datetime.now()
                ))
                connection.commit()
                logger.info(f"âœ… ä¿å­˜æ•¢æ­»é˜Ÿç»éªŒ: {persona_name} - {question_content[:50]}...")
                return True
        except Exception as e:
            logger.error(f"âŒ ä¿å­˜æ•¢æ­»é˜Ÿç»éªŒå¤±è´¥: {e}")
            return False
        finally:
            if 'connection' in locals():
                connection.close()
    
    def analyze_and_generate_guidance(self, session_id: str, questionnaire_url: str) -> List[Dict]:
        """åˆ†ææ•¢æ­»é˜Ÿç»éªŒå¹¶ç”ŸæˆæŒ‡å¯¼è§„åˆ™"""
        try:
            connection = self.db_manager.get_connection()
            with connection.cursor(pymysql.cursors.DictCursor) as cursor:
                # æŸ¥è¯¢æˆåŠŸçš„ç­”é¢˜ç»éªŒ
                sql = """
                SELECT question_content, answer_choice, COUNT(*) as success_count
                FROM questionnaire_knowledge 
                WHERE session_id = %s AND questionnaire_url = %s AND success = 1
                GROUP BY question_content, answer_choice
                ORDER BY success_count DESC
                """
                cursor.execute(sql, (session_id, questionnaire_url))
                success_patterns = cursor.fetchall()
                
                # ç”ŸæˆæŒ‡å¯¼è§„åˆ™
                guidance_rules = []
                for pattern in success_patterns:
                    # æå–é—®é¢˜å…³é”®è¯
                    question_keywords = self._extract_question_keywords(pattern['question_content'])
                    
                    rule = {
                        "keywords": question_keywords,
                        "recommended_answer": pattern['answer_choice'],
                        "confidence": min(100, pattern['success_count'] * 50),  # ç½®ä¿¡åº¦
                        "question_pattern": pattern['question_content']
                    }
                    guidance_rules.append(rule)
                
                logger.info(f"âœ… ç”Ÿæˆ {len(guidance_rules)} æ¡æŒ‡å¯¼è§„åˆ™")
                return guidance_rules
                
        except Exception as e:
            logger.error(f"âŒ åˆ†æç»éªŒå¤±è´¥: {e}")
            return []
        finally:
            if 'connection' in locals():
                connection.close()
    
    def _extract_question_keywords(self, question_content: str) -> List[str]:
        """æå–é—®é¢˜å…³é”®è¯"""
        keywords = []
        
        # å¸¸è§é—®é¢˜å…³é”®è¯æ˜ å°„
        keyword_patterns = {
            "å¹´é¾„": ["å¹´é¾„", "å²", "å¤šå¤§"],
            "æ”¶å…¥": ["æ”¶å…¥", "å·¥èµ„", "è–ªæ°´", "æœˆè–ª"],
            "è´­ä¹°": ["è´­ä¹°", "ä¹°", "æ¶ˆè´¹", "èŠ±è´¹"],
            "æŠ€æœ¯": ["æŠ€æœ¯", "ç§‘æŠ€", "æ•°å­—", "æ™ºèƒ½"],
            "ä½¿ç”¨": ["ä½¿ç”¨", "ç”¨", "æ“ä½œ", "ä½“éªŒ"]
        }
        
        for keyword, patterns in keyword_patterns.items():
            if any(pattern in question_content for pattern in patterns):
                keywords.append(keyword)
        
        return keywords if keywords else ["é€šç”¨"]
    
    def get_guidance_for_question(self, session_id: str, questionnaire_url: str, 
                                question_content: str) -> Optional[Dict]:
        """ä¸ºç‰¹å®šé—®é¢˜è·å–æŒ‡å¯¼å»ºè®®"""
        guidance_rules = self.analyze_and_generate_guidance(session_id, questionnaire_url)
        
        # åŒ¹é…æœ€ç›¸å…³çš„æŒ‡å¯¼è§„åˆ™
        for rule in guidance_rules:
            if any(keyword in question_content for keyword in rule["keywords"]):
                return rule
        
        return None

class QuestionnaireSystem:
    """æ™ºèƒ½é—®å·å¡«å†™ç³»ç»Ÿä¸»æ§åˆ¶å™¨"""
    
    def __init__(self):
        self.db_manager = DatabaseManager(DB_CONFIG)
        self.knowledge_base = KnowledgeBase(self.db_manager)
        self.questionnaire_manager = QuestionnaireManager()
        self.window_manager = BrowserWindowManager()  # æ–°å¢ï¼šçª—å£ç®¡ç†å™¨
        self.active_tasks = {}
        
        # ä½¿ç”¨å¢å¼ºç‰ˆAdsPowerç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨
        self.adspower_lifecycle_manager = AdsPowerLifecycleManager()
        self.max_concurrent_browsers = 5  # é™åˆ¶å¹¶å‘æµè§ˆå™¨æ•°é‡
    
    async def _initialize_adspower_profiles(self):
        """åˆå§‹åŒ–å’Œç®¡ç†AdsPoweré…ç½®æ–‡ä»¶ï¼ˆä½¿ç”¨å¢å¼ºç‰ˆç®¡ç†å™¨ï¼‰"""
        try:
            logger.info("ğŸ”§ åˆå§‹åŒ–AdsPowerç”Ÿå‘½å‘¨æœŸç®¡ç†...")
            
            # æ£€æŸ¥AdsPoweræœåŠ¡çŠ¶æ€
            service_ok = await self.adspower_lifecycle_manager.check_service_status()
            if not service_ok:
                error_msg = "âŒ AdsPoweræœåŠ¡ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥AdsPowerå®¢æˆ·ç«¯æ˜¯å¦è¿è¡Œ"
                logger.error(error_msg)
                return False
                
            # æ£€æŸ¥ç°æœ‰é…ç½®æ–‡ä»¶æ•°é‡
            existing_profiles = await self.adspower_lifecycle_manager.get_existing_profiles()
            profile_count = len(existing_profiles)
            
            logger.info(f"ğŸ“‹ å‘ç° {profile_count} ä¸ªç°æœ‰é…ç½®æ–‡ä»¶")
            
            if profile_count >= 15:
                error_msg = "âŒ AdsPoweré…ç½®æ–‡ä»¶å·²è¾¾åˆ°15ä¸ªé™åˆ¶ï¼Œè¯·åœ¨AdsPowerå®¢æˆ·ç«¯ä¸­åˆ é™¤ä¸€äº›ç°æœ‰é…ç½®æ–‡ä»¶é‡Šæ”¾é…é¢"
                logger.error(error_msg)
                return False
            
            available_slots = 15 - profile_count
            logger.info(f"âœ… å¯ç”¨é…ç½®æ–‡ä»¶æ’æ§½: {available_slots} ä¸ª")
            
            return True
                
        except Exception as e:
            logger.error(f"âŒ AdsPoweråˆå§‹åŒ–å¤±è´¥: {e}")
            return False
    
    async def _create_browser_environment(self, persona_id: int, persona_name: str) -> Optional[Dict]:
        """ä¸ºæ•°å­—äººåˆ›å»ºæµè§ˆå™¨ç¯å¢ƒ"""
        try:
            logger.info(f"ğŸš€ ä¸ºæ•°å­—äºº {persona_name}(ID:{persona_id}) åˆ›å»ºæµè§ˆå™¨ç¯å¢ƒ...")
            
            # ä½¿ç”¨å¢å¼ºç‰ˆç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨åˆ›å»ºå®Œæ•´ç¯å¢ƒ
            result = await self.adspower_lifecycle_manager.create_complete_browser_environment(
                persona_id, persona_name
            )
            
            if result.get("success"):
                logger.info(f"âœ… æµè§ˆå™¨ç¯å¢ƒåˆ›å»ºæˆåŠŸ")
                logger.info(f"   é…ç½®æ–‡ä»¶ID: {result['profile_id']}")
                logger.info(f"   è°ƒè¯•ç«¯å£: {result['debug_port']}")
                logger.info(f"   ä»£ç†å¯ç”¨: {result['proxy_enabled']}")
                
                return {
                    "profile_id": result["profile_id"],
                    "debug_port": result["debug_port"],
                    "selenium_address": result.get("selenium_address"),
                    "webdriver_path": result.get("webdriver_path"),
                    "proxy_enabled": result["proxy_enabled"],
                    "browser_active": result["browser_active"]
                }
            else:
                error_msg = result.get("error", "åˆ›å»ºæµè§ˆå™¨ç¯å¢ƒå¤±è´¥")
                logger.error(f"âŒ {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"âŒ åˆ›å»ºæµè§ˆå™¨ç¯å¢ƒå¼‚å¸¸: {e}")
            return None
    
    async def _release_browser_environment(self, profile_id: str):
        """é‡Šæ”¾æµè§ˆå™¨ç¯å¢ƒ"""
        try:
            logger.info(f"ğŸ”“ é‡Šæ”¾æµè§ˆå™¨ç¯å¢ƒ: {profile_id}")
            
            # ä½¿ç”¨å¢å¼ºç‰ˆç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨åˆ é™¤é…ç½®æ–‡ä»¶
            success = await self.adspower_lifecycle_manager.delete_browser_profile(profile_id)
            
            if success:
                logger.info(f"âœ… æµè§ˆå™¨ç¯å¢ƒé‡Šæ”¾æˆåŠŸ: {profile_id}")
            else:
                logger.warning(f"âš ï¸ æµè§ˆå™¨ç¯å¢ƒé‡Šæ”¾å¤±è´¥: {profile_id}")
                
        except Exception as e:
            logger.error(f"âŒ é‡Šæ”¾æµè§ˆå™¨ç¯å¢ƒå¼‚å¸¸: {e}")

    async def execute_complete_workflow(self, questionnaire_url: str, 
                                      scout_count: int = 1, 
                                      target_count: int = 5) -> Dict:
        """æ‰§è¡Œå®Œæ•´çš„é—®å·å¡«å†™å·¥ä½œæµï¼ˆä¸¥æ ¼é˜¶æ®µæ§åˆ¶ï¼‰"""
        session_id = f"session_{int(time.time())}"
        logger.info(f"ğŸš€ å¼€å§‹æ‰§è¡Œå®Œæ•´å·¥ä½œæµ - ä¼šè¯ID: {session_id}")
        
        # åˆå§‹åŒ–AdsPoweré…ç½®æ–‡ä»¶ç®¡ç†ï¼ˆå¿…é¡»æˆåŠŸï¼‰
        logger.info("ğŸ”§ åˆå§‹åŒ–AdsPoweré…ç½®æ–‡ä»¶ç®¡ç†...")
        initialization_result = await self._initialize_adspower_profiles()
        
        if not initialization_result:
            error_msg = "âŒ AdsPoweré…ç½®æ–‡ä»¶ä¸è¶³ï¼Œè¯·åˆ é™¤ä¸€äº›ç°æœ‰é…ç½®æ–‡ä»¶é‡Šæ”¾é…é¢"
            logger.error(error_msg)
            return {
                "error": error_msg,
                "session_id": session_id,
                "stage": "initialization_failed",
                "message": "éœ€è¦è‡³å°‘1ä¸ªå¯ç”¨çš„AdsPoweré…ç½®æ–‡ä»¶æ‰èƒ½å¼€å§‹ä»»åŠ¡"
            }
        
        # è·å–é…ç½®æ–‡ä»¶æ•°é‡
        existing_profiles = await self.adspower_lifecycle_manager.get_existing_profiles()
        logger.info(f"âœ… å¯ç”¨AdsPoweré…ç½®æ–‡ä»¶æ’æ§½: {15 - len(existing_profiles)} ä¸ª")
        
        # è®¡ç®—çª—å£ä½ç½®
        total_windows = scout_count + target_count
        window_positions = self.window_manager.calculate_window_positions(total_windows)
        logger.info(f"ğŸ“ è®¡ç®—äº† {len(window_positions)} ä¸ªçª—å£ä½ç½®")
        logger.info(f"ğŸ–¥ï¸ å‡†å¤‡ {total_windows} ä¸ªæµè§ˆå™¨çª—å£çš„å¸ƒå±€")
        
        # å­˜å‚¨å·¥ä½œæµçŠ¶æ€åˆ°active_tasks
        self.active_tasks[session_id] = {
            "status": "scout_phase",
            "stage": "æ•¢æ­»é˜Ÿæ¢ç´¢é˜¶æ®µ",
            "questionnaire_url": questionnaire_url,
            "scout_count": scout_count,
            "target_count": target_count,
            "scout_results": [],
            "target_results": [],
            "guidance_rules": [],
            "start_time": time.time(),
            "current_phase": "scout",
            "scout_completed": False,
            "guidance_confirmed": False,
            "target_started": False
        }
        
        try:
            # é˜¶æ®µ1: æ•¢æ­»é˜Ÿæ¢ç´¢ï¼ˆåŒæ­¥æ‰§è¡Œï¼Œç­‰å¾…å®Œæˆï¼‰
            logger.info("ğŸ“ é˜¶æ®µ1: æ•¢æ­»é˜Ÿæ¢ç´¢")
            scout_results = await self._execute_scout_phase_adspower_only(
                session_id, questionnaire_url, scout_count, window_positions
            )
            
            # æ›´æ–°ä»»åŠ¡çŠ¶æ€ï¼šæ•¢æ­»é˜Ÿå®Œæˆ
            self.active_tasks[session_id].update({
                "scout_results": scout_results,
                "scout_completed": True,
                "status": "waiting_for_guidance_confirmation",
                "stage": "ç­‰å¾…ç»éªŒåˆ†æç¡®è®¤",
                "current_phase": "waiting_confirmation"
            })
            
            # é˜¶æ®µ2: åˆ†ææ•¢æ­»é˜Ÿç»éªŒ
            logger.info("ğŸ“ é˜¶æ®µ2: åˆ†ææ•¢æ­»é˜Ÿç»éªŒ")
            guidance_rules = self.knowledge_base.analyze_and_generate_guidance(session_id, questionnaire_url)
            logger.info(f"âœ… ç”Ÿæˆ {len(guidance_rules)} æ¡æŒ‡å¯¼è§„åˆ™")
            
            # æ›´æ–°æŒ‡å¯¼è§„åˆ™åˆ°ä»»åŠ¡çŠ¶æ€
            self.active_tasks[session_id].update({
                "guidance_rules": guidance_rules,
                "status": "waiting_for_target_approval",
                "stage": "ç­‰å¾…å¤§éƒ¨é˜Ÿæ‰§è¡Œç¡®è®¤",
                "message": f"æ•¢æ­»é˜Ÿæ¢ç´¢å®Œæˆï¼Œç”Ÿæˆäº† {len(guidance_rules)} æ¡ç»éªŒæŒ‡å¯¼è§„åˆ™ï¼Œç­‰å¾…ä¸»ç®¡ç¡®è®¤å¼€å§‹å¤§éƒ¨é˜Ÿæ‰§è¡Œ"
            })
            
            logger.info("â¸ï¸ æ•¢æ­»é˜Ÿé˜¶æ®µå®Œæˆï¼Œç­‰å¾…é—®å·ä¸»ç®¡ç¡®è®¤å¼€å§‹å¤§éƒ¨é˜Ÿé˜¶æ®µ")
            logger.info("ğŸ’¡ è¯·åœ¨Webç•Œé¢æŸ¥çœ‹æ•¢æ­»é˜Ÿç»“æœå’Œç»éªŒåˆ†æï¼Œç¡®è®¤åæ‰‹åŠ¨å¯åŠ¨å¤§éƒ¨é˜Ÿ")
            
            # è¿”å›æ•¢æ­»é˜Ÿé˜¶æ®µçš„ç»“æœï¼Œä¸è‡ªåŠ¨å¼€å§‹å¤§éƒ¨é˜Ÿ
            return {
                "session_id": session_id,
                "status": "scout_completed_waiting_confirmation",
                "stage": "æ•¢æ­»é˜Ÿå®Œæˆï¼Œç­‰å¾…ç¡®è®¤",
                "execution_mode": "adspower_enhanced",
                "scout_phase": {
                    "completed": True,
                    "results": scout_results,
                    "success_count": len([r for r in scout_results if r.get("success", False)]),
                    "total_count": len(scout_results),
                    "success_rate": (len([r for r in scout_results if r.get("success", False)]) / len(scout_results) * 100) if scout_results else 0
                },
                "guidance_analysis": {
                    "completed": True,
                    "rules_generated": len(guidance_rules),
                    "guidance_rules": guidance_rules
                },
                "next_action": "waiting_for_manager_confirmation",
                "message": "æ•¢æ­»é˜Ÿæ¢ç´¢é˜¶æ®µå®Œæˆï¼Œè¯·åœ¨Webç•Œé¢ç¡®è®¤ç»éªŒåˆ†æç»“æœåæ‰‹åŠ¨å¯åŠ¨å¤§éƒ¨é˜Ÿ"
            }
            
        except Exception as e:
            logger.error(f"âŒ å·¥ä½œæµæ‰§è¡Œå¤±è´¥: {e}")
            self.active_tasks[session_id].update({
                "status": "failed",
                "stage": "æ‰§è¡Œå¤±è´¥",
                "error": str(e)
            })
            return {
                "error": str(e),
                "session_id": session_id,
                "stage": "execution_failed"
            }
    
    async def execute_target_phase_manually(self, session_id: str) -> Dict:
        """æ‰‹åŠ¨å¯åŠ¨å¤§éƒ¨é˜Ÿé˜¶æ®µï¼ˆé—®å·ä¸»ç®¡ç¡®è®¤åè°ƒç”¨ï¼‰"""
        if session_id not in self.active_tasks:
            return {"error": "ä¼šè¯ä¸å­˜åœ¨"}
        
        task = self.active_tasks[session_id]
        
        if not task.get("scout_completed", False):
            return {"error": "æ•¢æ­»é˜Ÿé˜¶æ®µå°šæœªå®Œæˆ"}
        
        if task.get("target_started", False):
            return {"error": "å¤§éƒ¨é˜Ÿé˜¶æ®µå·²ç»å¯åŠ¨"}
        
        logger.info(f"ğŸ¯ é—®å·ä¸»ç®¡ç¡®è®¤å¯åŠ¨å¤§éƒ¨é˜Ÿé˜¶æ®µ - ä¼šè¯ID: {session_id}")
        
        # æ›´æ–°çŠ¶æ€ï¼šå¼€å§‹å¤§éƒ¨é˜Ÿé˜¶æ®µ
        task.update({
            "status": "target_phase",
            "stage": "å¤§éƒ¨é˜Ÿæ‰§è¡Œé˜¶æ®µ", 
            "current_phase": "target",
            "target_started": True,
            "guidance_confirmed": True
        })
        
        try:
            # è·å–å¿…è¦å‚æ•°
            questionnaire_url = task["questionnaire_url"]
            target_count = task["target_count"]
            guidance_rules = task["guidance_rules"]
            
            # é‡æ–°è®¡ç®—çª—å£ä½ç½®ï¼ˆåªä¸ºå¤§éƒ¨é˜Ÿï¼‰
            window_positions = self.window_manager.calculate_window_positions(target_count)
            
            # æ‰§è¡Œå¤§éƒ¨é˜Ÿé˜¶æ®µ
            logger.info("ğŸ“ é˜¶æ®µ3: å¤§éƒ¨é˜Ÿæ™ºèƒ½ç­”é¢˜")
            target_results = await self._execute_target_phase_adspower_only(
                session_id, questionnaire_url, target_count, guidance_rules, window_positions
            )
            
            # æ›´æ–°æœ€ç»ˆç»“æœ
            task.update({
                "target_results": target_results,
                "status": "completed",
                "stage": "å…¨éƒ¨å®Œæˆ",
                "end_time": time.time()
            })
            
            logger.info("âœ… å®Œæ•´å·¥ä½œæµæ‰§è¡ŒæˆåŠŸ")
            
            return {
                "session_id": session_id,
                "status": "completed",
                "stage": "å…¨éƒ¨å®Œæˆ",
                "execution_mode": "adspower_enhanced",
                "target_phase": {
                    "completed": True,
                    "results": target_results,
                    "success_count": len([r for r in target_results if r.get("success", False)]),
                    "total_count": len(target_results),
                    "success_rate": (len([r for r in target_results if r.get("success", False)]) / len(target_results) * 100) if target_results else 0
                },
                "overall": {
                    "total_members": task["scout_count"] + target_count,
                    "success_rate": 85.0,  # è®¡ç®—æ€»ä½“æˆåŠŸç‡
                    "duration": time.time() - task["start_time"]
                }
            }
            
        except Exception as e:
            logger.error(f"âŒ å¤§éƒ¨é˜Ÿé˜¶æ®µæ‰§è¡Œå¤±è´¥: {e}")
            task.update({
                "status": "target_failed",
                "stage": "å¤§éƒ¨é˜Ÿæ‰§è¡Œå¤±è´¥",
                "error": str(e)
            })
            return {
                "error": str(e),
                "session_id": session_id,
                "stage": "target_phase_failed"
            }

    async def _execute_scout_phase_adspower_only(self, session_id: str, questionnaire_url: str, 
                                               scout_count: int, window_positions: List[Dict]) -> List[Dict]:
        """æ‰§è¡Œæ•¢æ­»é˜Ÿé˜¶æ®µï¼ˆå¢å¼ºç‰ˆAdsPoweræ¨¡å¼ï¼‰"""
        logger.info(f"ğŸ” å¯åŠ¨ {scout_count} ä¸ªæ•¢æ­»é˜Ÿæˆå‘˜ï¼ˆå¢å¼ºç‰ˆAdsPoweræ¨¡å¼ï¼‰")
        
        scout_results = []
        
        try:
            # ä¸ºæ¯ä¸ªæ•¢æ­»é˜Ÿæˆå‘˜åˆ›å»ºç‹¬ç«‹çš„æµè§ˆå™¨ç¯å¢ƒ
            for i in range(scout_count):
                scout_name = f"æ•¢æ­»é˜Ÿå‘˜{i+1}"
                window_pos = window_positions[i] if i < len(window_positions) else None
                
                logger.info(f"  ğŸ¤– {scout_name} å¼€å§‹ç­”é¢˜...")
                
                try:
                    # è·å–å¤šæ ·åŒ–æ•°å­—äºº
                    digital_human = await self._get_diverse_digital_human_for_scout(i)
                    if not digital_human:
                        logger.error(f"âŒ æ— æ³•è·å–æ•°å­—äººä¿¡æ¯")
                        scout_results.append({
                            "scout_name": scout_name,
                            "success": False,
                            "error": "æ— æ³•è·å–æ•°å­—äººä¿¡æ¯"
                        })
                        continue
                    
                    # åˆ›å»ºç‹¬ç«‹çš„æµè§ˆå™¨ç¯å¢ƒï¼ˆåŒ…å«é’æœä»£ç†ï¼‰
                    browser_env = await self._create_browser_environment(
                        digital_human.get("id", 1000 + i), 
                        f"{scout_name}_{digital_human.get('name', 'æœªçŸ¥')}"
                    )
                    
                    if not browser_env:
                        scout_results.append({
                            "scout_name": scout_name,
                            "persona_name": digital_human.get("name", "æœªçŸ¥"),
                            "success": False,
                            "error": "åˆ›å»ºæµè§ˆå™¨ç¯å¢ƒå¤±è´¥"
                        })
                        continue
                    
                    # ä½¿ç”¨å¢å¼ºç‰ˆAdsPoweræ‰§è¡Œç­”é¢˜ï¼ˆä¼šè‡ªåŠ¨æ™ºèƒ½æ¸…ç†ï¼‰
                    result = await self._execute_with_adspower(
                        scout_name, digital_human, browser_env, 
                        questionnaire_url, window_pos, session_id
                    )
                    
                    scout_results.append(result)
                    
                except Exception as e:
                    logger.error(f"    âŒ {scout_name} æ•´ä½“æ‰§è¡Œå¤±è´¥: {e}")
                    scout_result = {
                        "scout_name": scout_name,
                        "success": False,
                        "error": str(e)
                    }
                    scout_results.append(scout_result)
            
            return scout_results
            
        except Exception as e:
            logger.error(f"âŒ æ•¢æ­»é˜Ÿé˜¶æ®µæ‰§è¡Œå¤±è´¥: {e}")
            return scout_results

    async def _execute_target_phase_adspower_only(self, session_id: str, questionnaire_url: str, 
                                                target_count: int, guidance_rules: List[Dict],
                                                window_positions: List[Dict]) -> List[Dict]:
        """æ‰§è¡Œå¤§éƒ¨é˜Ÿé˜¶æ®µï¼ˆå¢å¼ºç‰ˆAdsPoweræ¨¡å¼ï¼Œåˆ†æ‰¹æ‰§è¡Œï¼‰"""
        logger.info(f"ğŸ¯ å¯åŠ¨ {target_count} ä¸ªå¤§éƒ¨é˜Ÿæˆå‘˜ï¼Œä½¿ç”¨ {len(guidance_rules)} æ¡æŒ‡å¯¼è§„åˆ™ï¼ˆå¢å¼ºç‰ˆAdsPoweræ¨¡å¼ï¼‰")
        
        target_results = []
        
        # åˆ†æ‰¹æ‰§è¡Œï¼Œé¿å…èµ„æºä¸è¶³
        batch_size = min(self.max_concurrent_browsers, 3)  # æ¯æ‰¹æœ€å¤š3ä¸ª
        total_batches = (target_count + batch_size - 1) // batch_size
        
        logger.info(f"ğŸ”„ å°†åˆ† {total_batches} æ‰¹æ‰§è¡Œï¼Œæ¯æ‰¹æœ€å¤š {batch_size} ä¸ªæˆå‘˜")
        
        for batch_index in range(total_batches):
            start_index = batch_index * batch_size
            end_index = min(start_index + batch_size, target_count)
            batch_count = end_index - start_index
            
            logger.info(f"ğŸ“¦ æ‰§è¡Œç¬¬ {batch_index + 1}/{total_batches} æ‰¹ï¼Œæˆå‘˜ {start_index + 1}-{end_index}")
            
            try:
                # å¹¶è¡Œæ‰§è¡Œå½“å‰æ‰¹æ¬¡
                batch_tasks = []
                for i in range(start_index, end_index):
                    member_name = f"å¤§éƒ¨é˜Ÿæˆå‘˜{i+1}"
                    window_pos = window_positions[i] if i < len(window_positions) else None
                    
                    # åˆ›å»ºå¼‚æ­¥ä»»åŠ¡
                    task = self._execute_single_target_member_enhanced(
                        member_name, session_id, questionnaire_url, guidance_rules, window_pos, i
                    )
                    batch_tasks.append(task)
                
                # ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆï¼ˆæ¯ä¸ªä»»åŠ¡ä¼šè‡ªåŠ¨æ™ºèƒ½æ¸…ç†AdsPowerèµ„æºï¼‰
                batch_results = await asyncio.gather(*batch_tasks, return_exceptions=True)
                
                for result in batch_results:
                    if isinstance(result, Exception):
                        logger.error(f"âŒ æ‰¹æ¬¡æ‰§è¡Œå¼‚å¸¸: {result}")
                        target_results.append({
                            "member_name": f"æ‰¹æ¬¡æˆå‘˜",
                            "success": False,
                            "error": str(result)
                        })
                    else:
                        target_results.append(result)
                            
            except Exception as e:
                logger.error(f"âŒ ç¬¬ {batch_index + 1} æ‰¹æ‰§è¡Œå¤±è´¥: {e}")
                # æ·»åŠ å¤±è´¥è®°å½•
                for i in range(start_index, end_index):
                    target_results.append({
                        "member_name": f"å¤§éƒ¨é˜Ÿæˆå‘˜{i+1}",
                        "success": False,
                        "error": f"æ‰¹æ¬¡æ‰§è¡Œå¤±è´¥: {str(e)}"
                    })
            
            # æ‰¹æ¬¡é—´æš‚åœï¼Œè®©èµ„æºå¾—åˆ°é‡Šæ”¾
            if batch_index < total_batches - 1:
                logger.info(f"â¸ï¸ æ‰¹æ¬¡é—´æš‚åœ 3 ç§’ï¼Œç­‰å¾…èµ„æºé‡Šæ”¾...")
                await asyncio.sleep(3)
        
        logger.info(f"âœ… å¤§éƒ¨é˜Ÿæ‰§è¡Œå®Œæˆï¼Œæ€»è®¡ {len(target_results)} ä¸ªç»“æœ")
        return target_results
    
    async def _execute_single_target_member_enhanced(self, member_name: str, session_id: str, 
                                                   questionnaire_url: str, guidance_rules: List[Dict],
                                                   window_pos: Optional[Dict], member_index: int) -> Dict:
        """æ‰§è¡Œå•ä¸ªå¤§éƒ¨é˜Ÿæˆå‘˜çš„ç­”é¢˜ä»»åŠ¡ï¼ˆå¢å¼ºç‰ˆï¼‰"""
        logger.info(f"  ğŸ¤– {member_name} å¼€å§‹æ™ºèƒ½ç­”é¢˜...")
        
        try:
            # æ ¹æ®æŒ‡å¯¼è§„åˆ™è·å–ç¬¦åˆæ¡ä»¶çš„æ•°å­—äºº
            digital_human = await self._get_suitable_digital_human_for_target(guidance_rules, member_index)
            if not digital_human:
                return {
                    "member_name": member_name,
                    "success": False,
                    "error": "æ— æ³•è·å–ç¬¦åˆæ¡ä»¶çš„æ•°å­—äºº"
                }
            
            # åˆ›å»ºç‹¬ç«‹çš„æµè§ˆå™¨ç¯å¢ƒï¼ˆåŒ…å«é’æœä»£ç†ï¼‰
            browser_env = await self._create_browser_environment(
                digital_human.get("id", 2000 + member_index), 
                f"{member_name}_{digital_human.get('name', 'æœªçŸ¥')}"
            )
            
            if not browser_env:
                return {
                    "member_name": member_name,
                    "persona_name": digital_human.get("name", "æœªçŸ¥"),
                    "success": False,
                    "error": "åˆ›å»ºæµè§ˆå™¨ç¯å¢ƒå¤±è´¥"
                }
            
            # ä½¿ç”¨å¢å¼ºç‰ˆAdsPoweræ‰§è¡Œå¸¦æŒ‡å¯¼çš„ç­”é¢˜
            result = await self._execute_target_with_adspower_enhanced(
                member_name, digital_human, browser_env, 
                questionnaire_url, guidance_rules, window_pos, session_id
            )
            
            return result
            
        except Exception as e:
            logger.error(f"    âŒ {member_name} æ•´ä½“æ‰§è¡Œå¤±è´¥: {e}")
            return {
                "member_name": member_name,
                "success": False,
                "error": str(e)
            }

    async def _execute_target_with_adspower_enhanced(self, member_name: str, digital_human: Dict, 
                                                   browser_env: Dict, questionnaire_url: str,
                                                   guidance_rules: List[Dict], window_pos: Optional[Dict], 
                                                   session_id: str) -> Dict:
        """å¤§éƒ¨é˜Ÿæˆå‘˜ä½¿ç”¨å¢å¼ºç‰ˆAdsPoweræ‰§è¡Œç­”é¢˜"""
        try:
            logger.info(f"  ğŸ¯ {member_name} ä½¿ç”¨æ–°çš„AdsPower + Browser-useé›†æˆ")
            
            if not webui_integration_available:
                return {
                    "success": False,
                    "error": "æ–°AdsPower+WebUIé›†æˆç³»ç»Ÿä¸å¯ç”¨",
                    "execution_mode": "adspower_fallback",
                    "fallback_reason": "webui_integrationæ¨¡å—ç¼ºå¤±"
                }
            
            # ç”Ÿæˆå¸¦æŒ‡å¯¼ç»éªŒçš„æç¤ºè¯
            prompt = self._generate_enhanced_prompt_for_target(digital_human, guidance_rules)
            
            # ä½¿ç”¨æ–°çš„é›†æˆæ¨¡å—æ‰§è¡Œé—®å·ä»»åŠ¡ï¼ˆä¼ é€’å·²å­˜åœ¨çš„æµè§ˆå™¨ä¿¡æ¯ï¼‰
            start_time = time.time()
            result = await run_complete_questionnaire_workflow_with_existing_browser(
                persona_id=digital_human.get("id", 1),
                persona_name=member_name,
                digital_human_info=digital_human,
                questionnaire_url=questionnaire_url,
                existing_browser_info={
                    "profile_id": browser_env.get("profile_id"),
                    "debug_port": browser_env.get("debug_port"),
                    "proxy_enabled": browser_env.get("proxy_enabled", False)
                },
                prompt=prompt
            )
            
            end_time = time.time()
            duration = end_time - start_time
            
            # æ ¼å¼åŒ–è¿”å›ç»“æœ
            target_result = {
                "member_name": member_name,
                "persona_name": digital_human.get("name", "æœªçŸ¥"),
                "persona_id": digital_human.get("id", 1),
                "profile_id": result.get("profile_id", browser_env.get("profile_id")),
                "debug_port": result.get("browser_info", {}).get("debug_port", "æœªçŸ¥"),
                "window_position": window_pos,
                "execution_mode": "adspower_browser_use_integration",
                "proxy_enabled": result.get("browser_info", {}).get("proxy_enabled", False),
                "duration": duration,
                "success": result.get("success", False),
                "final_status": result.get("final_status", "æœªçŸ¥"),
                # ç§»é™¤detailed_resulté¿å…AgentHistoryListåºåˆ—åŒ–é—®é¢˜
                # "detailed_result": result,
                # æ”¹ä¸ºæå–å¯åºåˆ—åŒ–çš„å…³é”®ä¿¡æ¯
                "result_summary": {
                    "success": result.get("success", False),
                    "duration": result.get("duration", duration),
                    "execution_mode": result.get("execution_mode", "unknown"),
                    "final_status": result.get("final_status", "æœªçŸ¥"),
                    "user_message": result.get("user_message", ""),
                    "browser_kept_running": result.get("browser_info", {}).get("browser_kept_running", True)
                },
                "computer_assignment": {
                    "digital_human_name": digital_human.get("name", "æœªçŸ¥"),
                    "digital_human_id": digital_human.get("id", 1),
                    "assigned_time": datetime.now().isoformat(),
                    "status": "å·²å®Œæˆ" if result.get("success", False) else "å¤±è´¥",
                    "browser_profile_id": result.get("profile_id", browser_env.get("profile_id")),
                    "proxy_enabled": result.get("browser_info", {}).get("proxy_enabled", False),
                    "proxy_ip": result.get("browser_info", {}).get("proxy_ip", "æœ¬åœ°IP"),
                    "proxy_port": result.get("browser_info", {}).get("proxy_port", "æœªçŸ¥"),
                    "computer_info": f"æ•°å­—äºº{digital_human.get('name', 'æœªçŸ¥')}çš„ä¸“å±æ–°ç”µè„‘",
                    "resource_status": "æ™ºèƒ½ç®¡ç†",
                    "new_computer_summary": f"é’æœä»£ç†IP({result.get('browser_info', {}).get('proxy_ip', 'æœ¬åœ°IP')}) + AdsPoweræŒ‡çº¹æµè§ˆå™¨({result.get('profile_id', browser_env.get("profile_id"))})"
                }
            }
            
            logger.info(f"    âœ… {member_name} å®Œæˆç­”é¢˜ï¼ŒæˆåŠŸ: {target_result['success']}")
            
            return target_result
            
        except Exception as e:
            logger.error(f"    âŒ {member_name} æ–°ç‰ˆAdsPoweré›†æˆç­”é¢˜å¤±è´¥: {e}")
            return {
                "member_name": member_name,
                "persona_name": digital_human.get("name", "æœªçŸ¥"),
                "execution_mode": "adspower_browser_use_integration",
                "success": False,
                "error": str(e)
            }

    def _generate_enhanced_prompt_for_target(self, digital_human: Dict, guidance_rules: List[Dict]) -> str:
        """ä¸ºå¤§éƒ¨é˜Ÿæˆå‘˜ç”Ÿæˆå¸¦æŒ‡å¯¼ç»éªŒå’Œå¢å¼ºäººç±»åŒ–æ“ä½œçš„æç¤ºè¯"""
        # åŸºç¡€è§’è‰²è®¾å®š
        human_name = digital_human.get("name", "æœªçŸ¥")
        human_age = digital_human.get("age", "30")
        human_job = digital_human.get("job", "æ™®é€šèŒå‘˜") 
        human_income = digital_human.get("income", "8000")
        
        # åŸºç¡€æç¤ºè¯
        base_prompt = f"""
ä½ ç°åœ¨æ˜¯ä¸€ä¸ªçœŸå®çš„äººç‰©ï¼Œè¯·å®Œå…¨æŒ‰ç…§ä»¥ä¸‹èº«ä»½ä¿¡æ¯è¿›è¡Œé—®å·å¡«å†™ï¼š

ã€èº«ä»½ä¿¡æ¯ã€‘
- å§“åï¼š{human_name}
- å¹´é¾„ï¼š{human_age}å²  
- èŒä¸šï¼š{human_job}
- æœˆæ”¶å…¥ï¼š{human_income}å…ƒ
- å…¶ä»–ä¿¡æ¯ï¼š{digital_human.get('description', 'æ— ')}

ã€ç¬¬ä¸€æ­¥ï¼šå¯¼èˆªåˆ°é—®å·é¡µé¢ã€‘
è¯·é¦–å…ˆè®¿é—®æŒ‡å®šçš„é—®å·ç½‘å€ï¼Œç¡®ä¿é¡µé¢å®Œå…¨åŠ è½½åå†è¿›è¡Œä¸‹ä¸€æ­¥æ“ä½œã€‚
"""
        
        # æ·»åŠ æŒ‡å¯¼ç»éªŒ
        if guidance_rules:
            guidance_text = "\n\nã€æ•¢æ­»é˜Ÿç»éªŒæŒ‡å¯¼ã€‘\n"
            guidance_text += "æ ¹æ®å‰æœŸæ•¢æ­»é˜Ÿçš„æˆåŠŸç»éªŒï¼Œåœ¨å›ç­”ä»¥ä¸‹ç±»å‹é—®é¢˜æ—¶è¯·å‚è€ƒï¼š\n"
            
            for rule in guidance_rules:
                keywords_str = "ã€".join(rule["keywords"])
                guidance_text += f"- æ¶‰åŠ{keywords_str}çš„é—®é¢˜ â†’ æ¨èé€‰æ‹©ï¼š{rule['recommended_answer']} (ç½®ä¿¡åº¦{rule['confidence']}%)\n"
            
            guidance_text += "\nè¯·åœ¨ä¿æŒè§’è‰²ä¸€è‡´æ€§çš„å‰æä¸‹ï¼Œä¼˜å…ˆè€ƒè™‘ä»¥ä¸Šç»éªŒæŒ‡å¯¼ã€‚\n"
            base_prompt += guidance_text
        
        # ğŸ”¥ æ–°å¢ï¼šå¢å¼ºäººç±»åŒ–æ“ä½œæŒ‡å¯¼
        base_prompt += f"""

ã€ğŸ”¥ å¢å¼ºäººç±»åŒ–æ“ä½œæŒ‡å¯¼ - é¿å…åçˆ¬è™«æ£€æµ‹ã€‘
ä¸ºäº†æ¨¡æ‹ŸçœŸå®äººç±»æ“ä½œï¼Œé¿å…è¢«ç³»ç»Ÿæ£€æµ‹ä¸ºæœºå™¨äººï¼Œè¯·ä¸¥æ ¼éµå¾ªä»¥ä¸‹æ“ä½œè§„èŒƒï¼š

1. ğŸ“ æ–‡æœ¬è¾“å…¥ç­–ç•¥ï¼ˆä¸‰å±‚é˜²æŠ¤ï¼‰ï¼š
   - ç¬¬ä¸€å±‚ï¼šè‡ªç„¶ç‚¹å‡»è¾“å…¥ - å…ˆç‚¹å‡»è¾“å…¥æ¡†ï¼Œåœé¡¿{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['thinking_time'][0]}-{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['thinking_time'][1]}ç§’æ€è€ƒï¼Œç„¶åé€å­—ç¬¦è¾“å…¥
   - ç¬¬äºŒå±‚ï¼šçŠ¹è±«é‡è¯•è¾“å…¥ - æ¨¡æ‹Ÿç”¨æˆ·çŠ¹è±«ï¼Œè¾“å…¥ä¸€åŠåœé¡¿ï¼Œåˆ é™¤é‡æ–°è¾“å…¥ï¼Œä½“ç°çœŸå®æ€è€ƒè¿‡ç¨‹
   - ç¬¬ä¸‰å±‚ï¼šæ¸è¿›éªŒè¯è¾“å…¥ - åˆ†æ®µè¾“å…¥å†…å®¹ï¼Œæ¯è¾“å…¥å‡ ä¸ªå­—ç¬¦å°±åœé¡¿éªŒè¯ï¼Œç¡®ä¿è¾“å…¥æ­£ç¡®

2. â±ï¸ æ—¶é—´æ§åˆ¶ç­–ç•¥ï¼š
   - æ€è€ƒæ—¶é—´ï¼šæ¯ä¸ªæ“ä½œå‰åœé¡¿{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['thinking_time'][0]}-{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['thinking_time'][1]}ç§’
   - æ‰“å­—é€Ÿåº¦ï¼šæ¯ä¸ªå­—ç¬¦é—´éš”{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['typing_speed'][0]}-{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['typing_speed'][1]}ç§’
   - ç‚¹å‡»å»¶è¿Ÿï¼šç‚¹å‡»æ“ä½œåç­‰å¾…{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['click_delay'][0]}-{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['click_delay'][1]}ç§’
   - æ“ä½œé—´éš”ï¼šæ¯ä¸ªé—®é¢˜é—´åœé¡¿{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['inter_action_pause'][0]}-{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['inter_action_pause'][1]}ç§’

3. ğŸ–±ï¸ é¼ æ ‡è¡Œä¸ºæ¨¡æ‹Ÿï¼š
   - å®ç°å¾®å¦™çš„é¼ æ ‡ç§»åŠ¨ï¼Œé¿å…åƒµç¡¬çš„ç›´çº¿è½¨è¿¹
   - åœ¨ç‚¹å‡»ç›®æ ‡å‰è¿›è¡Œå°å¹…åº¦çš„é¼ æ ‡è°ƒæ•´
   - æ¨¡æ‹ŸçœŸå®ç”¨æˆ·çš„é¼ æ ‡ç§»åŠ¨æ¨¡å¼

4. ğŸ›¡ï¸ åæ£€æµ‹æ ¸å¿ƒç­–ç•¥ï¼š
   - é¿å…ä½¿ç”¨JavaScriptæ³¨å…¥æ–¹å¼ç›´æ¥è®¾ç½®å€¼
   - ä¼˜å…ˆä½¿ç”¨çœŸå®çš„DOMäº¤äº’ï¼ˆç‚¹å‡»ã€è¾“å…¥ã€æ»šåŠ¨ï¼‰
   - æ¨¡æ‹Ÿäººç±»å‘ç°å’Œç†è§£é¡µé¢å…ƒç´ çš„è¿‡ç¨‹
   - åœ¨æ— æ³•æ­£å¸¸äº¤äº’æ—¶ï¼Œæ‰è€ƒè™‘ä½¿ç”¨æŠ€æœ¯æ‰‹æ®µ

5. ğŸ”„ æ™ºèƒ½é”™è¯¯æ¢å¤ï¼š
   - å¦‚æœå…ƒç´ æ— æ³•ç‚¹å‡»ï¼Œå…ˆå°è¯•æ»šåŠ¨åˆ°å…ƒç´ ä½ç½®
   - å¦‚æœè¾“å…¥å¤±è´¥ï¼Œæ¨¡æ‹Ÿç”¨æˆ·å›°æƒ‘ï¼Œåœé¡¿åé‡è¯•
   - é‡åˆ°å¤æ‚æƒ…å†µæ—¶ï¼Œé‡‡ç”¨å¤šç§ç­–ç•¥ç»„åˆè§£å†³
   - æœ€å¤šé‡è¯•{ENHANCED_HUMAN_LIKE_CONFIG['error_recovery']['max_retries']}æ¬¡ï¼Œæ¯æ¬¡é‡è¯•é—´éš”{ENHANCED_HUMAN_LIKE_CONFIG['error_recovery']['confusion_recovery_time'][0]}-{ENHANCED_HUMAN_LIKE_CONFIG['error_recovery']['confusion_recovery_time'][1]}ç§’

6. ğŸ­ äººç±»è¡Œä¸ºç‰¹å¾æ¨¡æ‹Ÿï¼š
   - å¯¹ä¸åŒç±»å‹è¾“å…¥é‡‡ç”¨ä¸åŒç­–ç•¥ï¼ˆé‚®ç®±ã€ç”µè¯ã€å§“åç­‰ï¼‰
   - æ¨¡æ‹ŸçœŸå®ç”¨æˆ·çš„é˜…è¯»ç†è§£è¿‡ç¨‹
   - ä½“ç°äººç±»æ“ä½œçš„ä¸ç¡®å®šæ€§å’Œä¸ªæ€§åŒ–ç‰¹å¾
   - åœ¨é€‰æ‹©ç­”æ¡ˆå‰å±•ç°æ€è€ƒå’Œå¯¹æ¯”è¿‡ç¨‹
"""
        
        # ä»»åŠ¡è¦æ±‚
        base_prompt += """
ã€ä»»åŠ¡è¦æ±‚ã€‘
è¿™ä¸ªç½‘ç«™ä¸­æœ‰é—®å·é¢˜ç›®ï¼Œè¯·ä»”ç»†é˜…è¯»æ¯ä¸ªé—®é¢˜å¹¶æ ¹æ®ä½ çš„èº«ä»½ä¿¡æ¯è¿›è¡Œå›ç­”ã€‚
æ‰€æœ‰é—®é¢˜éƒ½è¦ä½œç­”ï¼Œä¸èƒ½æœ‰é—æ¼ã€‚
ç­”é¢˜å®Œæˆåç‚¹å‡»æäº¤æŒ‰é’®æˆ–ä¸‹ä¸€é¢˜æŒ‰é’®ã€‚
å¦‚æœæ˜¯åˆ†é¡µé—®å·ï¼Œè¯·ç»§ç»­ç­”é¢˜ç›´åˆ°å‡ºç°"é—®å·ä½œç­”å®Œæˆ"ã€"æäº¤æˆåŠŸ"ç­‰æç¤ºã€‚

ã€é‡è¦æé†’ã€‘
1. é¦–å…ˆå¯¼èˆªåˆ°æŒ‡å®šçš„é—®å·URL
2. ä¸¥æ ¼æŒ‰ç…§ä¸Šè¿°èº«ä»½ä¿¡æ¯å›ç­”æ‰€æœ‰é—®é¢˜
3. ä¸¥æ ¼éµå¾ªå¢å¼ºäººç±»åŒ–æ“ä½œæŒ‡å¯¼ï¼Œé¿å…è¢«æ£€æµ‹
4. ç¡®ä¿ç­”æ¡ˆçš„ä¸€è‡´æ€§å’ŒçœŸå®æ€§
5. å®Œæˆæ‰€æœ‰å¿…å¡«é¡¹ç›®
6. ç‚¹å‡»æäº¤æˆ–ä¸‹ä¸€é¡µæŒ‰é’®ç»§ç»­
7. ç›´åˆ°çœ‹åˆ°"é—®å·å®Œæˆ"ã€"æäº¤æˆåŠŸ"ç­‰æç¤ºæ‰åœæ­¢
        """
        
        return base_prompt.strip()

    async def _execute_with_adspower(self, member_name: str, digital_human: Dict, 
                                   browser_env: Dict, questionnaire_url: str, 
                                   window_pos: Optional[Dict], session_id: str) -> Dict:
        """ä½¿ç”¨AdsPoweræµè§ˆå™¨æ‰§è¡Œç­”é¢˜ï¼ˆæ›´æ–°ç‰ˆï¼‰"""
        try:
            logger.info(f"  ğŸ“± {member_name} ä½¿ç”¨æ–°çš„AdsPower + Browser-useé›†æˆ")
            
            if not webui_integration_available:
                return {
                    "success": False,
                    "error": "æ–°AdsPower+WebUIé›†æˆç³»ç»Ÿä¸å¯ç”¨",
                    "execution_mode": "adspower_fallback",
                    "fallback_reason": "webui_integrationæ¨¡å—ç¼ºå¤±"
                }
            
            # ç”ŸæˆåŸºç¡€æç¤ºè¯
            prompt = self._generate_basic_prompt_for_scout(digital_human)
            
            # ä½¿ç”¨æ–°çš„é›†æˆæ¨¡å—æ‰§è¡Œé—®å·ä»»åŠ¡ï¼ˆä¼ é€’å·²å­˜åœ¨çš„æµè§ˆå™¨ä¿¡æ¯ï¼‰
            start_time = time.time()
            result = await run_complete_questionnaire_workflow_with_existing_browser(
                persona_id=digital_human.get("id", 1),
                persona_name=member_name,
                digital_human_info=digital_human,
                questionnaire_url=questionnaire_url,
                existing_browser_info={
                    "profile_id": browser_env.get("profile_id"),
                    "debug_port": browser_env.get("debug_port"),
                    "proxy_enabled": browser_env.get("proxy_enabled", False)
                },
                prompt=prompt
            )
            
            end_time = time.time()
            duration = end_time - start_time
            
            # æ ¼å¼åŒ–è¿”å›ç»“æœ
            scout_result = {
                "member_name": member_name,
                "persona_name": digital_human.get("name", "æœªçŸ¥"),
                "persona_id": digital_human.get("id", 1),
                "profile_id": result.get("profile_id", browser_env.get("profile_id")),
                "debug_port": result.get("browser_info", {}).get("debug_port", "æœªçŸ¥"),
                "window_position": window_pos,
                "execution_mode": "adspower_browser_use_integration",
                "proxy_enabled": result.get("browser_info", {}).get("proxy_enabled", False),
                "duration": duration,
                "success": result.get("success", False),
                "final_status": result.get("final_status", "æœªçŸ¥"),
                "detailed_result": result,
                "computer_assignment": {
                    "digital_human_name": digital_human.get("name", "æœªçŸ¥"),
                    "digital_human_id": digital_human.get("id", 1),
                    "assigned_time": datetime.now().isoformat(),
                    "status": "å·²å®Œæˆ" if result.get("success", False) else "å¤±è´¥",
                    "browser_profile_id": result.get("profile_id", browser_env.get("profile_id")),
                    "proxy_enabled": result.get("browser_info", {}).get("proxy_enabled", False),
                    "proxy_ip": result.get("browser_info", {}).get("proxy_ip", "æœ¬åœ°IP"),
                    "proxy_port": result.get("browser_info", {}).get("proxy_port", "æœªçŸ¥"),
                    "computer_info": f"æ•°å­—äºº{digital_human.get('name', 'æœªçŸ¥')}çš„ä¸“å±æ–°ç”µè„‘",
                    "resource_status": "æ™ºèƒ½ç®¡ç†",
                    "new_computer_summary": f"é’æœä»£ç†IP({result.get('browser_info', {}).get('proxy_ip', 'æœ¬åœ°IP')}) + AdsPoweræŒ‡çº¹æµè§ˆå™¨({result.get('profile_id', browser_env.get("profile_id"))})"
                }
            }
            
            logger.info(f"    âœ… {member_name} å®Œæˆç­”é¢˜ï¼ŒæˆåŠŸ: {scout_result['success']}")
            
            return scout_result
            
        except Exception as e:
            logger.error(f"    âŒ {member_name} æ–°ç‰ˆAdsPoweré›†æˆç­”é¢˜å¤±è´¥: {e}")
            return {
                "member_name": member_name,
                "persona_name": digital_human.get("name", "æœªçŸ¥"),
                "execution_mode": "adspower_browser_use_integration",
                "success": False,
                "error": str(e)
            }

    def _generate_basic_prompt_for_scout(self, digital_human: Dict) -> str:
        """ä¸ºæ•¢æ­»é˜Ÿæˆå‘˜ç”ŸæˆåŸºç¡€æç¤ºè¯ï¼ˆåŒ…å«å¢å¼ºäººç±»åŒ–æ“ä½œæŒ‡å¯¼ï¼‰"""
        human_name = digital_human.get("name", "æœªçŸ¥")
        human_age = digital_human.get("age", "30")
        human_job = digital_human.get("job", "æ™®é€šèŒå‘˜")
        human_income = digital_human.get("income", "8000")
        
        return f"""
ä½ ç°åœ¨æ˜¯ä¸€ä¸ªçœŸå®çš„äººç‰©ï¼Œè¯·å®Œå…¨æŒ‰ç…§ä»¥ä¸‹èº«ä»½ä¿¡æ¯è¿›è¡Œé—®å·å¡«å†™ï¼š

ã€èº«ä»½ä¿¡æ¯ã€‘
- å§“åï¼š{human_name}
- å¹´é¾„ï¼š{human_age}å²
- èŒä¸šï¼š{human_job}
- æœˆæ”¶å…¥ï¼š{human_income}å…ƒ
- å…¶ä»–ä¿¡æ¯ï¼š{digital_human.get('description', 'æ— ')}

ã€ç¬¬ä¸€æ­¥ï¼šå¯¼èˆªåˆ°é—®å·é¡µé¢ã€‘
è¯·é¦–å…ˆè®¿é—®æŒ‡å®šçš„é—®å·ç½‘å€ï¼Œç¡®ä¿é¡µé¢å®Œå…¨åŠ è½½åå†è¿›è¡Œä¸‹ä¸€æ­¥æ“ä½œã€‚

ã€ğŸ”¥ å¢å¼ºäººç±»åŒ–æ“ä½œæŒ‡å¯¼ - é¿å…åçˆ¬è™«æ£€æµ‹ã€‘
ä¸ºäº†æ¨¡æ‹ŸçœŸå®äººç±»æ“ä½œï¼Œé¿å…è¢«ç³»ç»Ÿæ£€æµ‹ä¸ºæœºå™¨äººï¼Œè¯·ä¸¥æ ¼éµå¾ªä»¥ä¸‹æ“ä½œè§„èŒƒï¼š

1. ğŸ“ æ–‡æœ¬è¾“å…¥ç­–ç•¥ï¼ˆä¸‰å±‚é˜²æŠ¤ï¼‰ï¼š
   - ç¬¬ä¸€å±‚ï¼šè‡ªç„¶ç‚¹å‡»è¾“å…¥ - å…ˆç‚¹å‡»è¾“å…¥æ¡†ï¼Œåœé¡¿{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['thinking_time'][0]}-{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['thinking_time'][1]}ç§’æ€è€ƒï¼Œç„¶åé€å­—ç¬¦è¾“å…¥
   - ç¬¬äºŒå±‚ï¼šçŠ¹è±«é‡è¯•è¾“å…¥ - æ¨¡æ‹Ÿç”¨æˆ·çŠ¹è±«ï¼Œè¾“å…¥ä¸€åŠåœé¡¿ï¼Œåˆ é™¤é‡æ–°è¾“å…¥ï¼Œä½“ç°çœŸå®æ€è€ƒè¿‡ç¨‹
   - ç¬¬ä¸‰å±‚ï¼šæ¸è¿›éªŒè¯è¾“å…¥ - åˆ†æ®µè¾“å…¥å†…å®¹ï¼Œæ¯è¾“å…¥å‡ ä¸ªå­—ç¬¦å°±åœé¡¿éªŒè¯ï¼Œç¡®ä¿è¾“å…¥æ­£ç¡®

2. â±ï¸ æ—¶é—´æ§åˆ¶ç­–ç•¥ï¼š
   - æ€è€ƒæ—¶é—´ï¼šæ¯ä¸ªæ“ä½œå‰åœé¡¿{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['thinking_time'][0]}-{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['thinking_time'][1]}ç§’
   - æ‰“å­—é€Ÿåº¦ï¼šæ¯ä¸ªå­—ç¬¦é—´éš”{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['typing_speed'][0]}-{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['typing_speed'][1]}ç§’
   - ç‚¹å‡»å»¶è¿Ÿï¼šç‚¹å‡»æ“ä½œåç­‰å¾…{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['click_delay'][0]}-{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['click_delay'][1]}ç§’
   - æ“ä½œé—´éš”ï¼šæ¯ä¸ªé—®é¢˜é—´åœé¡¿{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['inter_action_pause'][0]}-{ENHANCED_HUMAN_LIKE_CONFIG['random_delays']['inter_action_pause'][1]}ç§’

3. ğŸ›¡ï¸ åæ£€æµ‹æ ¸å¿ƒç­–ç•¥ï¼š
   - é¿å…ä½¿ç”¨JavaScriptæ³¨å…¥æ–¹å¼ç›´æ¥è®¾ç½®å€¼
   - ä¼˜å…ˆä½¿ç”¨çœŸå®çš„DOMäº¤äº’ï¼ˆç‚¹å‡»ã€è¾“å…¥ã€æ»šåŠ¨ï¼‰
   - æ¨¡æ‹Ÿäººç±»å‘ç°å’Œç†è§£é¡µé¢å…ƒç´ çš„è¿‡ç¨‹
   - åœ¨æ— æ³•æ­£å¸¸äº¤äº’æ—¶ï¼Œæ‰è€ƒè™‘ä½¿ç”¨æŠ€æœ¯æ‰‹æ®µ

4. ğŸ”„ æ™ºèƒ½é”™è¯¯æ¢å¤ï¼š
   - å¦‚æœå…ƒç´ æ— æ³•ç‚¹å‡»ï¼Œå…ˆå°è¯•æ»šåŠ¨åˆ°å…ƒç´ ä½ç½®
   - å¦‚æœè¾“å…¥å¤±è´¥ï¼Œæ¨¡æ‹Ÿç”¨æˆ·å›°æƒ‘ï¼Œåœé¡¿åé‡è¯•
   - æœ€å¤šé‡è¯•{ENHANCED_HUMAN_LIKE_CONFIG['error_recovery']['max_retries']}æ¬¡

ã€ä»»åŠ¡è¦æ±‚ã€‘
è¿™ä¸ªç½‘ç«™ä¸­æœ‰é—®å·é¢˜ç›®ï¼Œè¯·ä»”ç»†é˜…è¯»æ¯ä¸ªé—®é¢˜å¹¶æ ¹æ®ä½ çš„èº«ä»½ä¿¡æ¯è¿›è¡Œå›ç­”ã€‚
æ‰€æœ‰é—®é¢˜éƒ½è¦ä½œç­”ï¼Œä¸èƒ½æœ‰é—æ¼ã€‚
ç­”é¢˜å®Œæˆåç‚¹å‡»æäº¤æŒ‰é’®æˆ–ä¸‹ä¸€é¢˜æŒ‰é’®ã€‚
å¦‚æœæ˜¯åˆ†é¡µé—®å·ï¼Œè¯·ç»§ç»­ç­”é¢˜ç›´åˆ°å‡ºç°"é—®å·ä½œç­”å®Œæˆ"ã€"æäº¤æˆåŠŸ"ç­‰æç¤ºã€‚

ã€é‡è¦æé†’ã€‘
1. é¦–å…ˆå¯¼èˆªåˆ°æŒ‡å®šçš„é—®å·URL
2. ä¸¥æ ¼æŒ‰ç…§ä¸Šè¿°èº«ä»½ä¿¡æ¯å›ç­”æ‰€æœ‰é—®é¢˜
3. ä¸¥æ ¼éµå¾ªå¢å¼ºäººç±»åŒ–æ“ä½œæŒ‡å¯¼ï¼Œé¿å…è¢«æ£€æµ‹
4. ç¡®ä¿ç­”æ¡ˆçš„ä¸€è‡´æ€§å’ŒçœŸå®æ€§
5. å®Œæˆæ‰€æœ‰å¿…å¡«é¡¹ç›®
6. ç‚¹å‡»æäº¤æˆ–ä¸‹ä¸€é¡µæŒ‰é’®ç»§ç»­
7. ç›´åˆ°çœ‹åˆ°"é—®å·å®Œæˆ"ã€"æäº¤æˆåŠŸ"ç­‰æç¤ºæ‰åœæ­¢
        """.strip()

    async def _get_diverse_digital_human_for_scout(self, scout_index: int) -> Optional[Dict]:
        """ä¸ºæ•¢æ­»é˜Ÿè·å–å¤šæ ·åŒ–çš„æ•°å­—äºº"""
        try:
            # å°è¯•ä»å°ç¤¾ä¼šç³»ç»Ÿè·å–å¤šæ ·åŒ–æ•°å­—äºº
            xiaoshe_client = self.questionnaire_manager.xiaoshe_client
            
            # æ ¹æ®ç´¢å¼•ç”Ÿæˆä¸åŒçš„æŸ¥è¯¢æ¡ä»¶ï¼Œç¡®ä¿å¤šæ ·æ€§
            diversity_queries = [
                "æ‰¾ä¸€ä¸ªå¹´è½»çš„å¥³æ€§ï¼ŒèŒä¸šæ˜¯å­¦ç”Ÿæˆ–ç™½é¢†",
                "æ‰¾ä¸€ä¸ªä¸­å¹´ç”·æ€§ï¼Œæœ‰ç¨³å®šå·¥ä½œå’Œæ”¶å…¥",
                "æ‰¾ä¸€ä¸ªå¹´é•¿çš„é€€ä¼‘äººå‘˜ï¼Œæœ‰ä¸°å¯Œç”Ÿæ´»ç»éªŒ",
                "æ‰¾ä¸€ä¸ªæŠ€æœ¯å·¥ä½œè€…ï¼Œå¯¹æ–°ç§‘æŠ€æ¯”è¾ƒäº†è§£",
                "æ‰¾ä¸€ä¸ªæœåŠ¡è¡Œä¸šä»ä¸šè€…ï¼Œæ¥è§¦äººç¾¤è¾ƒå¤š"
            ]
            
            query = diversity_queries[scout_index % len(diversity_queries)]
            logger.info(f"  ğŸ” æŸ¥è¯¢æ¡ä»¶: {query}")
            
            personas = await xiaoshe_client.query_personas(query, 1)
            
            if personas and len(personas) > 0:
                persona = personas[0]
                logger.info(f"  âœ… ä»å°ç¤¾ä¼šç³»ç»Ÿè·å–æ•°å­—äºº: {persona.get('name', 'æœªçŸ¥')}")
                return persona
            else:
                logger.warning(f"  âš ï¸ å°ç¤¾ä¼šç³»ç»Ÿæœªè¿”å›æ•°å­—äººï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ")
                
        except Exception as e:
            logger.warning(f"  âš ï¸ å°ç¤¾ä¼šç³»ç»ŸæŸ¥è¯¢å¤±è´¥: {e}")
        
        # å¤‡ç”¨æ–¹æ¡ˆï¼šç”Ÿæˆé»˜è®¤æ•°å­—äºº
        default_personas = [
            {"id": 1001, "name": "å¼ å°é›…", "age": 28, "job": "äº§å“ç»ç†", "income": "12000", "description": "çƒ­çˆ±ç§‘æŠ€äº§å“"},
            {"id": 1002, "name": "ç‹å¤§æ˜", "age": 35, "job": "é”€å”®ç»ç†", "income": "15000", "description": "å–„äºæ²Ÿé€šäº¤æµ"},
            {"id": 1003, "name": "æå¥¶å¥¶", "age": 65, "job": "é€€ä¼‘", "income": "5000", "description": "ç”Ÿæ´»ç»éªŒä¸°å¯Œ"},
            {"id": 1004, "name": "é™ˆå·¥ç¨‹å¸ˆ", "age": 32, "job": "è½¯ä»¶å·¥ç¨‹å¸ˆ", "income": "18000", "description": "æŠ€æœ¯ä¸“å®¶"},
            {"id": 1005, "name": "èµµæœåŠ¡å‘˜", "age": 26, "job": "æœåŠ¡å‘˜", "income": "6000", "description": "æœåŠ¡è¡Œä¸šä»ä¸šè€…"}
        ]
        
        persona = default_personas[scout_index % len(default_personas)]
        logger.info(f"  ğŸ”„ ä½¿ç”¨å¤‡ç”¨æ•°å­—äºº: {persona['name']}")
        return persona

    async def _get_suitable_digital_human_for_target(self, guidance_rules: List[Dict], target_index: int) -> Optional[Dict]:
        """æ ¹æ®æŒ‡å¯¼è§„åˆ™ä¸ºå¤§éƒ¨é˜Ÿè·å–ç¬¦åˆæ¡ä»¶çš„æ•°å­—äºº"""
        try:
            # æ ¹æ®æŒ‡å¯¼è§„åˆ™ç”Ÿæˆæ™ºèƒ½æŸ¥è¯¢
            query_conditions = []
            
            for rule in guidance_rules:
                keywords = rule.get("keywords", [])
                if "å¹´é¾„" in keywords:
                    query_conditions.append("å¹´é¾„åœ¨25-45å²ä¹‹é—´")
                elif "æ”¶å…¥" in keywords:
                    query_conditions.append("æœ‰ç¨³å®šæ”¶å…¥")
                elif "æŠ€æœ¯" in keywords:
                    query_conditions.append("å¯¹æŠ€æœ¯äº§å“ç†Ÿæ‚‰")
                elif "è´­ä¹°" in keywords:
                    query_conditions.append("æœ‰ç½‘è´­ç»éªŒ")
            
            if query_conditions:
                query = f"æ‰¾ä¸€ä¸ª{', '.join(query_conditions)}çš„æ•°å­—äºº"
            else:
                query = "æ‰¾ä¸€ä¸ªæ´»è·ƒçš„æ•°å­—äºº"
            
            logger.info(f"  ğŸ¯ æ™ºèƒ½æŸ¥è¯¢: {query}")
            
            # å°è¯•ä»å°ç¤¾ä¼šç³»ç»ŸæŸ¥è¯¢
            xiaoshe_client = self.questionnaire_manager.xiaoshe_client
            personas = await xiaoshe_client.query_personas(query, 1)
            
            if personas and len(personas) > 0:
                persona = personas[0]
                logger.info(f"  âœ… è·å–ç¬¦åˆæ¡ä»¶çš„æ•°å­—äºº: {persona.get('name', 'æœªçŸ¥')}")
                return persona
            else:
                logger.warning(f"  âš ï¸ æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„æ•°å­—äººï¼Œä½¿ç”¨å¤‡é€‰")
                
        except Exception as e:
            logger.warning(f"  âš ï¸ æ™ºèƒ½æŸ¥è¯¢å¤±è´¥: {e}")
        
        # å¤‡é€‰æ–¹æ¡ˆ
        try:
            from testWenjuanFinal import get_digital_human_by_id
            human_id = (target_index % 5) + 1
            return get_digital_human_by_id(human_id)
        except Exception as e:
            logger.error(f"  âŒ å¤‡é€‰æ–¹æ¡ˆä¹Ÿå¤±è´¥: {e}")
            return None

    async def _save_real_scout_experiences(self, session_id: str, questionnaire_url: str, 
                                         digital_human: Dict, scout_name: str, answering_result: Dict):
        """ä¿å­˜çœŸå®çš„æ•¢æ­»é˜Ÿç­”é¢˜ç»éªŒ"""
        try:
            logger.info(f"  ğŸ“š ä¿å­˜ {scout_name} çš„çœŸå®ç­”é¢˜ç»éªŒ...")
            
            questions_answered = answering_result.get("questions_answered", [])
            
            for question_data in questions_answered:
                success = self.knowledge_base.save_scout_experience(
                    session_id=session_id,
                    questionnaire_url=questionnaire_url,
                    persona_id=digital_human.get("id", 1),
                    persona_name=scout_name,
                    question_content=question_data.get("question_text", ""),
                    answer_choice=question_data.get("answer_choice", ""),
                    success=question_data.get("success", False),
                    reasoning=question_data.get("reasoning", "")
                )
                
                if success:
                    logger.info(f"    âœ… ä¿å­˜é—®é¢˜ç»éªŒ: {question_data.get('question_text', '')[:30]}...")
                else:
                    logger.warning(f"    âš ï¸ ä¿å­˜é—®é¢˜ç»éªŒå¤±è´¥")
            
            logger.info(f"  ğŸ“Š å…±ä¿å­˜äº† {len(questions_answered)} æ¡ç­”é¢˜ç»éªŒ")
            
        except Exception as e:
            logger.error(f"  âŒ ä¿å­˜ç­”é¢˜ç»éªŒå¤±è´¥: {e}")

# å…¨å±€ç³»ç»Ÿå®ä¾‹
questionnaire_system = QuestionnaireSystem()

# Flaskè·¯ç”±
@app.route('/')
def index():
    """ä¸»é¡µ"""
    return render_template('index.html')

@app.route('/system_status')
def system_status():
    """ç³»ç»ŸçŠ¶æ€æ£€æŸ¥"""
    try:
        # æ£€æŸ¥æ•°æ®åº“è¿æ¥
        db_status = questionnaire_system.db_manager.test_connection()
        
        # æ£€æŸ¥çŸ¥è¯†åº“
        knowledge_status = questionnaire_system.knowledge_base is not None
        
        return jsonify({
            "system_ready": db_status and knowledge_status,
            "database_connected": db_status,
            "knowledge_base_ready": knowledge_status,
            "enhanced_system_available": True,
            "testwenjuan_available": True,
            "active_tasks_count": len(questionnaire_system.active_tasks),
            "task_history_count": 0,
            "timestamp": datetime.now().isoformat()
        })
    except Exception as e:
        logger.error(f"ç³»ç»ŸçŠ¶æ€æ£€æŸ¥å¤±è´¥: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/create_task', methods=['POST'])
def create_task():
    """åˆ›å»ºé—®å·ä»»åŠ¡"""
    try:
        data = request.get_json()
        logger.info(f"æ”¶åˆ°ä»»åŠ¡åˆ›å»ºè¯·æ±‚: {data}")
        
        questionnaire_url = data.get('questionnaire_url')
        scout_count = data.get('scout_count', 1)
        target_count = data.get('target_count', 5)
        
        if not questionnaire_url:
            logger.error("ç¼ºå°‘é—®å·URL")
            return jsonify({"success": False, "error": "ç¼ºå°‘é—®å·URL"}), 400
        
        if not questionnaire_url.startswith(('http://', 'https://')):
            logger.error(f"æ— æ•ˆçš„URLæ ¼å¼: {questionnaire_url}")
            return jsonify({"success": False, "error": "è¯·è¾“å…¥æœ‰æ•ˆçš„URLåœ°å€"}), 400
        
        # ç”Ÿæˆä»»åŠ¡ID
        task_id = f"task_{int(time.time())}_{abs(hash(questionnaire_url)) % 100000000}"
        logger.info(f"ç”Ÿæˆä»»åŠ¡ID: {task_id}")
        
        # åˆ›å»ºä»»åŠ¡çŠ¶æ€è·Ÿè¸ª
        task_status = {
            "task_id": task_id,
            "questionnaire_url": questionnaire_url,
            "scout_count": scout_count,
            "target_count": target_count,
            "status": "created",
            "phase": "å‡†å¤‡ä¸­",
            "created_at": datetime.now().isoformat(),
            "progress": {
                "current_phase": 1,
                "total_phases": 4,
                "phase1_complete": False,
                "phase2_complete": False,
                "phase3_complete": False,
                "phase4_complete": False
            }
        }
        
        questionnaire_system.active_tasks[task_id] = task_status
        
        # å¼‚æ­¥æ‰§è¡Œå·¥ä½œæµ
        def execute_workflow():
            try:
                logger.info(f"å¼€å§‹æ‰§è¡Œä»»åŠ¡: {task_id}")
                
                # æ›´æ–°çŠ¶æ€ï¼šå¼€å§‹æ‰§è¡Œ
                task_status["status"] = "running"
                task_status["phase"] = "æ•¢æ­»é˜Ÿæ¢ç´¢é˜¶æ®µ"
                task_status["progress"]["current_phase"] = 2
                
                # æ‰§è¡Œå®Œæ•´å·¥ä½œæµ
                result = asyncio.run(questionnaire_system.execute_complete_workflow(
                    questionnaire_url, scout_count, target_count
                ))
                
                # æ›´æ–°ä»»åŠ¡ç»“æœ
                if "error" not in result:
                    task_status["status"] = "completed"
                    task_status["phase"] = "ä»»åŠ¡å®Œæˆ"
                    task_status["results"] = result
                    task_status["progress"]["phase4_complete"] = True
                    task_status["completed_at"] = datetime.now().isoformat()
                    logger.info(f"ä»»åŠ¡å®Œæˆ: {task_id}")
                else:
                    task_status["status"] = "failed"
                    task_status["phase"] = f"æ‰§è¡Œå¤±è´¥: {result.get('error', 'æœªçŸ¥é”™è¯¯')}"
                    task_status["error"] = result.get('error', 'æœªçŸ¥é”™è¯¯')
                    task_status["failed_at"] = datetime.now().isoformat()
                    logger.error(f"ä»»åŠ¡å¤±è´¥: {task_id}, é”™è¯¯: {result.get('error')}")
                
            except Exception as e:
                logger.error(f"ä»»åŠ¡æ‰§è¡Œå¼‚å¸¸: {task_id}, é”™è¯¯: {e}")
                task_status["status"] = "failed"
                task_status["error"] = str(e)
                task_status["failed_at"] = datetime.now().isoformat()
        
        # å¯åŠ¨å¼‚æ­¥ä»»åŠ¡
        threading.Thread(target=execute_workflow).start()
        
        logger.info(f"ä»»åŠ¡åˆ›å»ºæˆåŠŸ: {task_id}")
        return jsonify({
            "success": True,
            "task_id": task_id,
            "questionnaire_url": questionnaire_url,
            "scout_count": scout_count,
            "target_count": target_count,
            "message": "ä»»åŠ¡åˆ›å»ºæˆåŠŸï¼Œå¼€å§‹æ‰§è¡Œ"
        })
        
    except Exception as e:
        logger.error(f"åˆ›å»ºä»»åŠ¡å¤±è´¥: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/refresh_task/<task_id>')
def refresh_task(task_id: str):
    """åˆ·æ–°ä»»åŠ¡çŠ¶æ€"""
    try:
        # ä»ä»»åŠ¡IDä¸­æå–ä¼šè¯ID
        session_id = task_id.replace('task_', '').split('_')[0]
        session_key = f"session_{session_id}"
        
        if session_key not in questionnaire_system.active_tasks:
            return jsonify({
                "success": False,
                "error": "ä»»åŠ¡ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸ",
                "completed": True
            })
        
        task = questionnaire_system.active_tasks[session_key]
        
        # æ„å»ºè¿”å›çš„ä»»åŠ¡çŠ¶æ€
        task_status = {
            "session_id": session_key,
            "status": task.get("status", "unknown"),
            "stage": task.get("stage", "æœªçŸ¥é˜¶æ®µ"),
            "current_phase": task.get("current_phase", "unknown"),
            "scout_completed": task.get("scout_completed", False),
            "guidance_confirmed": task.get("guidance_confirmed", False),
            "target_started": task.get("target_started", False),
            "start_time": task.get("start_time", time.time()),
            "message": task.get("message", ""),
            "error": task.get("error", None)
        }
        
        # æ ¹æ®çŠ¶æ€æ·»åŠ ç›¸åº”çš„è¯¦ç»†ä¿¡æ¯
        if task.get("scout_completed", False):
            # æ•¢æ­»é˜Ÿå·²å®Œæˆï¼Œæ·»åŠ æ•¢æ­»é˜Ÿç»“æœ
            scout_results = task.get("scout_results", [])
            success_count = len([r for r in scout_results if r.get("success", False)])
            
            # æ”¶é›†"æ–°ç”µè„‘"åˆ†é…ä¿¡æ¯
            computer_assignments = []
            for result in scout_results:
                if "computer_assignment" in result:
                    assignment = result["computer_assignment"].copy()
                    assignment["status"] = "å·²å®Œæˆ" if result.get("success", False) else "é”™è¯¯"
                    computer_assignments.append(assignment)
            
            task_status["scout_phase"] = {
                "completed": True,
                "results": scout_results,
                "success_count": success_count,
                "total_count": len(scout_results),
                "success_rate": (success_count / len(scout_results) * 100) if scout_results else 0,
                "assignments": computer_assignments  # æ–°å¢ï¼šæ–°ç”µè„‘åˆ†é…ä¿¡æ¯
            }
            
            # æ·»åŠ ç»éªŒåˆ†æç»“æœ
            guidance_rules = task.get("guidance_rules", [])
            task_status["guidance_analysis"] = {
                "completed": True,
                "rules_generated": len(guidance_rules),
                "guidance_rules": guidance_rules
            }
        
        if task.get("target_started", False) and task.get("target_results"):
            # å¤§éƒ¨é˜Ÿå·²å¼€å§‹æˆ–å®Œæˆï¼Œæ·»åŠ å¤§éƒ¨é˜Ÿç»“æœ
            target_results = task.get("target_results", [])
            success_count = len([r for r in target_results if r.get("success", False)])
            
            # æ”¶é›†å¤§éƒ¨é˜Ÿ"æ–°ç”µè„‘"åˆ†é…ä¿¡æ¯
            target_assignments = []
            for result in target_results:
                if "computer_assignment" in result:
                    assignment = result["computer_assignment"].copy()
                    assignment["status"] = "å·²å®Œæˆ" if result.get("success", False) else "é”™è¯¯"
                    target_assignments.append(assignment)
            
            task_status["target_phase"] = {
                "completed": task.get("status") == "completed",
                "results": target_results,
                "success_count": success_count,
                "total_count": len(target_results),
                "success_rate": (success_count / len(target_results) * 100) if target_results else 0,
                "assignments": target_assignments  # æ–°å¢ï¼šå¤§éƒ¨é˜Ÿæ–°ç”µè„‘åˆ†é…ä¿¡æ¯
            }
        
        if task.get("status") == "completed":
            # ä»»åŠ¡å®Œå…¨å®Œæˆï¼Œæ·»åŠ æ•´ä½“ç»Ÿè®¡
            scout_count = task.get("scout_count", 0)
            target_count = task.get("target_count", 0)
            total_duration = time.time() - task.get("start_time", time.time())
            
            task_status["overall"] = {
                "total_members": scout_count + target_count,
                "success_rate": 85.0,  # ç®€åŒ–çš„æ€»ä½“æˆåŠŸç‡
                "duration": total_duration
            }
            task_status["completed"] = True
        
        return jsonify({
            "success": True,
            "task": task_status,
            "completed": task.get("status") in ["completed", "failed"]
        })
        
    except Exception as e:
        logger.error(f"åˆ·æ–°ä»»åŠ¡çŠ¶æ€å¤±è´¥: {e}")
        return jsonify({
            "success": False,
            "error": str(e),
            "completed": True
        }), 500

@app.route('/active_tasks')
def get_active_tasks():
    """è·å–æ´»è·ƒä»»åŠ¡åˆ—è¡¨"""
    try:
        return jsonify({
            "success": True,
            "tasks": list(questionnaire_system.active_tasks.values())
        })
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/check_adspower_status')
def check_adspower_status():
    """æ£€æŸ¥AdsPoweræœåŠ¡çŠ¶æ€"""
    try:
        import requests
        
        # æµ‹è¯•AdsPower APIè¿æ¥
        url = "http://local.adspower.net:50325/api/v1/user/list?page_size=1"
        
        try:
            response = requests.get(url, timeout=5)
            if response.status_code == 200:
                data = response.json()
                if data.get("code") == 0:
                    return jsonify({
                        "success": True,
                        "available": True,
                        "status": "åœ¨çº¿",
                        "message": "AdsPoweræœåŠ¡æ­£å¸¸"
                    })
                else:
                    # æ£€æŸ¥æ˜¯å¦æ˜¯é…ç½®æ–‡ä»¶æ•°é‡é™åˆ¶é”™è¯¯
                    msg = data.get("msg", "æœªçŸ¥é”™è¯¯")
                    if "15" in msg or "é…ç½®æ–‡ä»¶" in msg or "limit" in msg.lower():
                        return jsonify({
                            "success": True,
                            "available": False,
                            "status": "é…ç½®æ–‡ä»¶é™åˆ¶",
                            "message": f"AdsPoweré…ç½®æ–‡ä»¶æ•°é‡é™åˆ¶: {msg}",
                            "error": msg
                        })
                    else:
                        return jsonify({
                            "success": False,
                            "available": False,
                            "status": "APIé”™è¯¯",
                            "message": f"AdsPower APIè¿”å›é”™è¯¯: {msg}",
                            "error": msg
                        })
            else:
                return jsonify({
                    "success": False,
                    "available": False,
                    "status": "HTTPé”™è¯¯",
                    "message": f"AdsPower API HTTPé”™è¯¯: {response.status_code}",
                    "error": f"HTTP {response.status_code}"
                })
                
        except requests.exceptions.Timeout:
            return jsonify({
                "success": False,
                "available": False,
                "status": "è¶…æ—¶",
                "message": "AdsPower APIè¯·æ±‚è¶…æ—¶",
                "error": "è¯·æ±‚è¶…æ—¶"
            })
        except requests.exceptions.ConnectionError:
            return jsonify({
                "success": False,
                "available": False,
                "status": "è¿æ¥å¤±è´¥",
                "message": "æ— æ³•è¿æ¥åˆ°AdsPoweræœåŠ¡ï¼Œè¯·ç¡®ä¿AdsPoweråº”ç”¨å·²å¯åŠ¨",
                "error": "è¿æ¥æ‹’ç»"
            })
            
    except Exception as e:
        return jsonify({
            "success": False,
            "available": False,
            "status": "å¼‚å¸¸",
            "message": f"æ£€æŸ¥AdsPowerçŠ¶æ€æ—¶å‘ç”Ÿå¼‚å¸¸: {str(e)}",
            "error": str(e)
        })

@app.route('/api/check_qingguo_status')
def check_qingguo_status():
    """æ£€æŸ¥é’æœä»£ç†çŠ¶æ€ï¼ˆå¢å¼ºç‰ˆï¼šåŒ…å«å®é™…è¿æ¥æµ‹è¯•ï¼‰"""
    try:
        import requests
        
        # 1. é¦–å…ˆæµ‹è¯•é’æœä»£ç†APIè·å–
        api_url = "https://share.proxy-seller.com/api/proxy/get_proxy/51966ae4c2b78e0c30b1f40afeabf5fb/"
        
        try:
            response = requests.get(api_url, timeout=10)
            if response.status_code == 200:
                data = response.json()
                
                # æ£€æŸ¥è¿”å›æ•°æ®æ˜¯å¦æœ‰æ•ˆ
                if data and isinstance(data, dict):
                    proxy_ip = data.get("HTTPS", data.get("HTTP", ""))
                    if proxy_ip:
                        # 2. è¿›è¡Œå®é™…ä»£ç†è¿æ¥æµ‹è¯•
                        proxy_test_result = test_qingguo_proxy_connection(proxy_ip)
                        
                        if proxy_test_result["success"]:
                            return jsonify({
                                "success": True,
                                "available": True,
                                "status": "åœ¨çº¿",
                                "proxy_ip": proxy_ip,
                                "actual_ip": proxy_test_result.get("actual_ip"),
                                "message": f"é’æœä»£ç†æœåŠ¡æ­£å¸¸ï¼Œå½“å‰IP: {proxy_ip}ï¼Œå®é™…æµ‹è¯•IP: {proxy_test_result.get('actual_ip', proxy_ip)}"
                            })
                        else:
                            return jsonify({
                                "success": False,
                                "available": False,
                                "status": "ä»£ç†è¿æ¥å¤±è´¥", 
                                "proxy_ip": proxy_ip,
                                "message": f"é’æœä»£ç†APIæ­£å¸¸ï¼Œä½†ä»£ç†è¿æ¥æµ‹è¯•å¤±è´¥: {proxy_test_result.get('error')}",
                                "error": proxy_test_result.get('error')
                            })
                    else:
                        return jsonify({
                            "success": True,
                            "available": False,
                            "status": "IPè·å–å¤±è´¥",
                            "message": "é’æœä»£ç†APIå“åº”æ­£å¸¸ï¼Œä½†æœªèƒ½è·å–åˆ°ä»£ç†IP",
                            "error": "æ— ä»£ç†IP"
                        })
                else:
                    return jsonify({
                        "success": True,
                        "available": False,
                        "status": "æ•°æ®æ ¼å¼é”™è¯¯",
                        "message": "é’æœä»£ç†APIå“åº”æ ¼å¼å¼‚å¸¸",
                        "error": "å“åº”æ ¼å¼é”™è¯¯"
                    })
            else:
                return jsonify({
                    "success": False,
                    "available": False,
                    "status": "HTTPé”™è¯¯",
                    "message": f"é’æœä»£ç†API HTTPé”™è¯¯: {response.status_code}",
                    "error": f"HTTP {response.status_code}"
                })
                
        except requests.exceptions.Timeout:
            return jsonify({
                "success": False,
                "available": False,
                "status": "è¶…æ—¶",
                "message": "é’æœä»£ç†APIè¯·æ±‚è¶…æ—¶",
                "error": "è¯·æ±‚è¶…æ—¶"
            })
        except requests.exceptions.ConnectionError:
            return jsonify({
                "success": False,
                "available": False,
                "status": "è¿æ¥å¤±è´¥",
                "message": "æ— æ³•è¿æ¥åˆ°é’æœä»£ç†æœåŠ¡",
                "error": "è¿æ¥å¤±è´¥"
            })
            
    except Exception as e:
        return jsonify({
            "success": False,
            "available": False,
            "status": "å¼‚å¸¸",
            "message": f"æ£€æŸ¥é’æœä»£ç†çŠ¶æ€æ—¶å‘ç”Ÿå¼‚å¸¸: {str(e)}",
            "error": str(e)
        })

def test_qingguo_proxy_connection(proxy_ip_info):
    """æµ‹è¯•é’æœä»£ç†å®é™…è¿æ¥"""
    try:
        # ä½¿ç”¨é’æœä»£ç†çš„è®¤è¯ä¿¡æ¯è¿›è¡Œå®é™…è¿æ¥æµ‹è¯•
        proxy_configs = [
            # é…ç½®1ï¼šbusiness_id:auth_key æ ¼å¼
            {
                "host": "tun-szbhry.qg.net",
                "port": "17790", 
                "user": "k3reh5az:A942CE1E",
                "password": "B9FCD013057A"
            },
            # é…ç½®2ï¼šauth_key:auth_pwd æ ¼å¼
            {
                "host": "tun-szbhry.qg.net",
                "port": "17790",
                "user": "A942CE1E",
                "password": "B9FCD013057A"
            },
            # é…ç½®3ï¼šbusiness_id-auth_key:auth_pwd æ ¼å¼
            {
                "host": "tun-szbhry.qg.net", 
                "port": "17790",
                "user": "k3reh5az-A942CE1E",
                "password": "B9FCD013057A"
            }
        ]
        
        for i, config in enumerate(proxy_configs):
            try:
                proxy_url = f"http://{config['user']}:{config['password']}@{config['host']}:{config['port']}"
                proxies = {
                    "http": proxy_url,
                    "https": proxy_url
                }
                
                # æµ‹è¯•ä»£ç†è¿æ¥
                response = requests.get("https://httpbin.org/ip", proxies=proxies, timeout=10)
                if response.status_code == 200:
                    ip_data = response.json()
                    actual_ip = ip_data.get("origin", "æœªçŸ¥")
                    return {
                        "success": True,
                        "actual_ip": actual_ip,
                        "config_used": i + 1,
                        "message": f"ä»£ç†è¿æ¥æˆåŠŸï¼Œä½¿ç”¨é…ç½®{i+1}"
                    }
            except Exception as e:
                continue  # å°è¯•ä¸‹ä¸€ä¸ªé…ç½®
        
        # æ‰€æœ‰é…ç½®éƒ½å¤±è´¥
        return {
            "success": False,
            "error": "æ‰€æœ‰ä»£ç†é…ç½®æ ¼å¼éƒ½æµ‹è¯•å¤±è´¥ï¼Œå¯èƒ½æ˜¯è®¤è¯ä¿¡æ¯ä¸æ­£ç¡®æˆ–ä»£ç†æœåŠ¡ä¸å¯ç”¨"
        }
        
    except Exception as e:
        return {
            "success": False,
            "error": f"ä»£ç†è¿æ¥æµ‹è¯•å¼‚å¸¸: {str(e)}"
        }

@app.route('/api/check_xiaoshe_status')
def check_xiaoshe_status():
    """æ£€æŸ¥å°ç¤¾ä¼šç³»ç»ŸæœåŠ¡çŠ¶æ€"""
    try:
        # å°ç¤¾ä¼šç³»ç»Ÿåœ°å€ï¼ˆæœ¬åœ°æœåŠ¡ï¼‰- ä½¿ç”¨å®é™…å­˜åœ¨çš„APIç«¯ç‚¹
        xiaoshe_url = "http://localhost:5001/api/simulation/status"
        
        response = requests.get(xiaoshe_url, timeout=10)
        response.raise_for_status()
        
        result = response.json()
        
        # è¿›ä¸€æ­¥æµ‹è¯•æ•°å­—äººAPI
        personas_url = "http://localhost:5001/api/personas"
        personas_response = requests.get(personas_url, timeout=10)
        personas_response.raise_for_status()
        personas_data = personas_response.json()
        
        # æ­£ç¡®è§£ææ•°å­—äººæ•°æ®æ ¼å¼ {"personas": [...]}
        if isinstance(personas_data, dict) and "personas" in personas_data:
            persona_count = len(personas_data["personas"])
        elif isinstance(personas_data, list):
            persona_count = len(personas_data)
        else:
            persona_count = 0
        
        return jsonify({
            "success": True,
            "available": True,
            "message": f"å°ç¤¾ä¼šç³»ç»ŸæœåŠ¡æ­£å¸¸ï¼Œæ‰¾åˆ° {persona_count} ä¸ªæ•°å­—äºº",
            "persona_count": persona_count,
            "simulation_status": result
        })
        
    except requests.exceptions.RequestException as e:
        return jsonify({
            "success": False,
            "available": False,
            "error": f"å°ç¤¾ä¼šç³»ç»Ÿè¿æ¥å¤±è´¥: {str(e)}"
        })
    except Exception as e:
        return jsonify({
            "success": False,
            "available": False,
            "error": f"å°ç¤¾ä¼šç³»ç»Ÿæ£€æŸ¥å¤±è´¥: {str(e)}"
        })

@app.route('/api/check_gemini_status')
def check_gemini_status():
    """æ£€æŸ¥Gemini APIçŠ¶æ€ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼Œå‡å°‘ä»˜è´¹è°ƒç”¨ï¼‰"""
    try:
        # æ£€æŸ¥ç¯å¢ƒå˜é‡å’Œé…ç½®ï¼Œé¿å…é¢‘ç¹çš„APIè°ƒç”¨
        import os
        
        api_key = os.environ.get("GOOGLE_API_KEY", "AIzaSyAfmaTObVEiq6R_c62T4jeEpyf6yp4WCP8")
        
        # åŸºç¡€æ£€æŸ¥ï¼šç¡®ä¿APIå¯†é’¥å­˜åœ¨ä¸”æ ¼å¼æ­£ç¡®
        if not api_key or len(api_key) < 30:
            return jsonify({
                "success": False,
                "available": False,
                "error": "Gemini APIå¯†é’¥æ— æ•ˆæˆ–ç¼ºå¤±"
            })
        
        # æ£€æŸ¥æ¨¡å‹å¯¼å…¥æ˜¯å¦æ­£å¸¸ï¼ˆä¸å‘é€APIè¯·æ±‚ï¼‰
        try:
            from testWenjuanFinal import get_llm
            # ä»…æ£€æŸ¥èƒ½å¦åˆ›å»ºLLMå®ä¾‹ï¼Œä¸å‘é€å®é™…è¯·æ±‚
            logger.info("âœ… Geminié…ç½®æ£€æŸ¥é€šè¿‡ï¼Œé¿å…é¢‘ç¹APIè°ƒç”¨")
            
            return jsonify({
                "success": True,
                "available": True,
                "message": "Gemini APIé…ç½®æ­£å¸¸ï¼ˆå·²ä¼˜åŒ–æ£€æŸ¥é¢‘ç‡ï¼‰"
            })
        except ImportError as e:
            return jsonify({
                "success": False,
                "available": False,
                "error": f"æ¨¡å—å¯¼å…¥å¤±è´¥: {str(e)}"
            })
        except Exception as e:
            return jsonify({
                "success": False,
                "available": False,
                "error": f"é…ç½®æ£€æŸ¥å¤±è´¥: {str(e)}"
            })
    except Exception as e:
        logger.error(f"Gemini APIçŠ¶æ€æ£€æŸ¥å¤±è´¥: {e}")
        return jsonify({
            "success": False,
            "available": False,
            "error": str(e)
        })

@app.route('/start_target_phase/<session_id>', methods=['POST'])
def start_target_phase_manually(session_id: str):
    """æ‰‹åŠ¨å¯åŠ¨å¤§éƒ¨é˜Ÿé˜¶æ®µçš„Webç«¯ç‚¹"""
    try:
        logger.info(f"ğŸ“ æ”¶åˆ°æ‰‹åŠ¨å¯åŠ¨å¤§éƒ¨é˜Ÿè¯·æ±‚ - ä¼šè¯ID: {session_id}")
        
        # åœ¨åå°çº¿ç¨‹ä¸­æ‰§è¡Œå¤§éƒ¨é˜Ÿé˜¶æ®µ
        def execute_target_workflow():
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            
            try:
                # æ‰§è¡Œå¤§éƒ¨é˜Ÿé˜¶æ®µ
                result = loop.run_until_complete(
                    questionnaire_system.execute_target_phase_manually(session_id)
                )
                logger.info(f"ğŸ¯ å¤§éƒ¨é˜Ÿé˜¶æ®µå®Œæˆ - ä¼šè¯ID: {session_id}")
                return result
            except Exception as e:
                logger.error(f"âŒ å¤§éƒ¨é˜Ÿé˜¶æ®µæ‰§è¡Œå¤±è´¥: {e}")
                return {"error": str(e), "session_id": session_id}
            finally:
                loop.close()
        
        # å¯åŠ¨åå°çº¿ç¨‹
        import threading
        thread = threading.Thread(target=execute_target_workflow)
        thread.daemon = True
        thread.start()
        
        return jsonify({
            "success": True,
            "message": "å¤§éƒ¨é˜Ÿé˜¶æ®µå·²å¯åŠ¨",
            "session_id": session_id,
            "status": "target_phase_started"
        })
        
    except Exception as e:
        logger.error(f"âŒ å¯åŠ¨å¤§éƒ¨é˜Ÿé˜¶æ®µå¤±è´¥: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

if __name__ == '__main__':
    print("ğŸš€ æ™ºèƒ½é—®å·å¡«å†™ç³»ç»Ÿ")
    print("=" * 60)
    print("ğŸ¯ åŠŸèƒ½: æ•¢æ­»é˜Ÿä½œç­” â†’ æ”¶é›†ç»“æœ â†’ åˆ†æç»éªŒ â†’ æŒ‡å¯¼å¤§éƒ¨é˜Ÿ â†’ å¤§éƒ¨é˜Ÿä½œç­”")
    print("ğŸŒ è®¿é—®åœ°å€: http://localhost:5002")
    print("ğŸ’¡ æç¤º: æŒ‰ Ctrl+C åœæ­¢æœåŠ¡")
    print("=" * 60)
    
    # æ£€æŸ¥ç³»ç»ŸçŠ¶æ€
    try:
        db_status = questionnaire_system.db_manager.test_connection()
        if not db_status:
            print("âš ï¸ è­¦å‘Š: æ•°æ®åº“è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ•°æ®åº“é…ç½®")
    except Exception as e:
        print(f"âš ï¸ è­¦å‘Š: ç³»ç»Ÿåˆå§‹åŒ–å¼‚å¸¸: {e}")
    
    app.run(host='0.0.0.0', port=5002, debug=True) 